% --- DON'T EDIT THIS FILE, IT IS GENERATED FROM SRC/ ---



== Macros ==
%NEED:11
%FUNCTION:BEGIN
=== BOOLEAN_STR ===[fn_BOOLEAN_STR]

**Definition:**

%DEFINITION:BEGIN
BOOLEAN_STR( b ) - //Macro//
%DEFINITION:END

**Usage:**

Returns the string represenation of the value or expression in //b//.
%FUNCTION:END
%NEED:11
%FUNCTION:BEGIN
=== CORE ===[fn_CORE]

**Definition:**

%DEFINITION:BEGIN
CORE  - //Macro//
%DEFINITION:END

**Usage:**

Enforces a SIGSEGV by writing to invalid memory.
%FUNCTION:END
%NEED:11
%FUNCTION:BEGIN
=== FALSE ===[fn_FALSE]

**Definition:**

%DEFINITION:BEGIN
FALSE  - //Macro//
%DEFINITION:END

**Usage:**

Value 0 for FALSE.
%FUNCTION:END
%NEED:17
%FUNCTION:BEGIN
=== LOG ===[fn_LOG]

**Definition:**

%DEFINITION:BEGIN
LOG( char* format, ... ) - //Macro//
%DEFINITION:END

**Usage:**

Write any logging output to trace.

This function is newer than the previous ones, and allows for a printf-like
format string with variable amount of parameters.

//format// is a [printf() #fn_printf]-like format-string.
//...// parameters in the way they occur in the format-string.
%FUNCTION:END
%NEED:11
%FUNCTION:BEGIN
=== MAKE_BOOLEAN ===[fn_MAKE_BOOLEAN]

**Definition:**

%DEFINITION:BEGIN
MAKE_BOOLEAN( b ) - //Macro//
%DEFINITION:END

**Usage:**

Turns the value or expression //b// into a pboolean value TRUE or FALSE.
%FUNCTION:END
%NEED:12
%FUNCTION:BEGIN
=== MISSINGCASE ===[fn_MISSINGCASE]

**Definition:**

%DEFINITION:BEGIN
MISSINGCASE  - //Macro//
%DEFINITION:END

**Usage:**

Prints "missing case engaged" into stderr, to indicate switch-case
constructs running into default-branch because any other branch is not engaged.
%FUNCTION:END
%NEED:13
%FUNCTION:BEGIN
=== MSG ===[fn_MSG]

**Definition:**

%DEFINITION:BEGIN
MSG( char* message ) - //Macro//
%DEFINITION:END

**Usage:**

Write a message to trace.

//message// is your message!
%FUNCTION:END
%NEED:11
%FUNCTION:BEGIN
=== OUTOFMEM ===[fn_OUTOFMEM]

**Definition:**

%DEFINITION:BEGIN
OUTOFMEM  - //Macro//
%DEFINITION:END

**Usage:**

Prints "ran out of memory" into stderr and exits with status 1.
%FUNCTION:END
%NEED:20
%FUNCTION:BEGIN
=== PARMS ===[fn_PARMS]

**Definition:**

%DEFINITION:BEGIN
PARMS( char* param_name, char* format, param_type parameter ) - //Macro//
%DEFINITION:END

**Usage:**

Write parameter content to trace.

The PARMS-macro is used to write parameter names and values to the program
trace. [PARMS() #fn_PARMS] should - by definition - only be used right behind [PROC() #fn_PROC].
If the logging of variable values is wanted during a function execution to
trace, the [VARS() #fn_VARS]-macro shall be used.

//param_name// is the name of the parameter
//format// is a printf-styled format placeholder.
//parameter// is the parameter itself.
%FUNCTION:END
%NEED:22
%FUNCTION:BEGIN
=== PROC ===[fn_PROC]

**Definition:**

%DEFINITION:BEGIN
PROC( char* func_name ) - //Macro//
%DEFINITION:END

**Usage:**

Write function entry to trace.

The PROC-macro introduces a new function level, if compiled with trace.

The PROC-macro must be put behind the last local variable declaration and the
first code line, else it won't compile. A PROC-macro must exists within a
function to allow for other trace-macro usages. If [PROC() #fn_PROC] is used within a
function, the macros [RETURN() #fn_RETURN] or VOIDRET, according to the function return
value, must be used. If PROC is used without RETURN, the trace output will
output a wrong call level depth.

The parameter //func_name// is a static string for the function name.
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== RETURN ===[fn_RETURN]

**Definition:**

%DEFINITION:BEGIN
RETURN( function_type return_value ) - //Macro//
%DEFINITION:END

**Usage:**

Write function return to trace.
 [RETURN() #fn_RETURN] can only be used if [PROC() #fn_PROC] is used at the beginning of the function.
For void-functions, use the macro VOIDRET.

//return_value// is return-value of the function.
%FUNCTION:END
%NEED:11
%FUNCTION:BEGIN
=== TODO ===[fn_TODO]

**Definition:**

%DEFINITION:BEGIN
TODO  - //Macro//
%DEFINITION:END

**Usage:**

Prints "TODO alert!" into stderr, to inform about incomplete branches.
%FUNCTION:END
%NEED:11
%FUNCTION:BEGIN
=== TRUE ===[fn_TRUE]

**Definition:**

%DEFINITION:BEGIN
TRUE  - //Macro//
%DEFINITION:END

**Usage:**

Value 1 for TRUE.
%FUNCTION:END
%NEED:18
%FUNCTION:BEGIN
=== VARS ===[fn_VARS]

**Definition:**

%DEFINITION:BEGIN
VARS( char* var_name, char* format, var_type variable ) - //Macro//
%DEFINITION:END

**Usage:**

Write variable content to trace.

The VARS-macro is used to write variable names and values to the program trace.
For parameters taken to functions, the [PARMS() #fn_PARMS]-macro shall be used.

//var_name// is the name of the variable
//format// is a printf-styled format placeholder.
//variable// is the parameter itself.
%FUNCTION:END
%NEED:14
%FUNCTION:BEGIN
=== VOIDRET ===[fn_VOIDRET]

**Definition:**

%DEFINITION:BEGIN
VOIDRET - //Macro//
%DEFINITION:END

**Usage:**

Write void function return to trace.

VOIDRET can only be used if [PROC() #fn_PROC] is used at the beginning of the function.
For typed functions, use the macro [RETURN() #fn_RETURN].
%FUNCTION:END
%NEED:12
%FUNCTION:BEGIN
=== WRONGPARAM ===[fn_WRONGPARAM]

**Definition:**

%DEFINITION:BEGIN
WRONGPARAM  - //Macro//
%DEFINITION:END

**Usage:**

Prints "function called with wrong or incomplete parameters" into stderr,
to indicate invalid function calls.
%FUNCTION:END
%NEED:32
%FUNCTION:BEGIN
=== parray_for ===[fn_parray_for]

**Definition:**

%DEFINITION:BEGIN
parray_for( parray* array, usertype* ptr ) - //Macro//
%DEFINITION:END

**Usage:**

Macro that expands into a for-loop iterating a parray-object //array// using
and pointer variable //ptr// as walker.

This macro expands into a for-loop in the format

``` for( ptr = parray_first( array ); ptr; ptr = parray_next( array, ptr ) )

where //ptr// is a walker variable of the same type size of the array's size
for each element.

**Example:**

```
usertype* 	t;
parray		a;

parray_init( &a, sizeof( usertype ), 0 );

parray_for( a, t )
{
	/* Do something with t *}
```
%FUNCTION:END
%NEED:31
%FUNCTION:BEGIN
=== plist_for ===[fn_plist_for]

**Definition:**

%DEFINITION:BEGIN
plist_for( plist* l, plistel* e ) - //Macro//
%DEFINITION:END

**Usage:**

Macro that expands into a for-loop iterating a plist-object //l// using
the element variable //e// as walker.

This macro expands into a for-loop of the format

``` for( e = plist_first( l ); e; e = plist_next( e ) )

where //e// is a walker variable for each element.

**Example:**

```
plist*		my_list;
plistel*	e;

plist_for( my_list, e )
{
	/* Access current element data part *	ptr = (cast*)plist_access( e );
	...
}
```
%FUNCTION:END
== Functions ==
%NEED:15
%FUNCTION:BEGIN
=== parray_concat ===[fn_parray_concat]

**Definition:**

%DEFINITION:BEGIN
size_t parray_concat( parray* dest, parray* src )
%DEFINITION:END

**Usage:**

Concats the elements of array //src// to the elements of array //dest//.

The function will not run if both arrays have different element size settings.

The function returns the number of elements added to //dest//.
%FUNCTION:END
%NEED:11
%FUNCTION:BEGIN
=== parray_count ===[fn_parray_count]

**Definition:**

%DEFINITION:BEGIN
size_t parray_count( parray* array )
%DEFINITION:END

**Usage:**

Returns the number of elements in a array.
%FUNCTION:END
%NEED:14
%FUNCTION:BEGIN
=== parray_create ===[fn_parray_create]

**Definition:**

%DEFINITION:BEGIN
parray* parray_create( size_t size, size_t chunk )
%DEFINITION:END

**Usage:**

Create a new parray as an object with an element allocation size //size//,
a reallocation-chunk-size of //chunk//.

The returned memory must be released with [parray_free() #fn_parray_free].
%FUNCTION:END
%NEED:16
%FUNCTION:BEGIN
=== parray_diff ===[fn_parray_diff]

**Definition:**

%DEFINITION:BEGIN
int parray_diff( parray* left, parray* right )
%DEFINITION:END

**Usage:**

Tests the contents (data parts) of the array //left// and the array //right//
for equal elements.

The function returns a value < 0 if //left// is lower //right//, a value > 0
if //left// is greater //right// and a value == 0 if //left// is equal to
//right//.
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== parray_erase ===[fn_parray_erase]

**Definition:**

%DEFINITION:BEGIN
void parray_erase( parray* array )
%DEFINITION:END

**Usage:**

Erase a dynamic array.

The array must not be reinitialized after destruction, using [parray_init() #fn_parray_init].

//array// is the pointer to the array to be erased.
%FUNCTION:END
%NEED:14
%FUNCTION:BEGIN
=== parray_first ===[fn_parray_first]

**Definition:**

%DEFINITION:BEGIN
void* parray_first( parray* array )
%DEFINITION:END

**Usage:**

Access first element of the array.

Returns the address of the accessed item, and NULL if nothing is in
the array.
%FUNCTION:END
%NEED:13
%FUNCTION:BEGIN
=== parray_free ===[fn_parray_free]

**Definition:**

%DEFINITION:BEGIN
parray* parray_free( parray* array )
%DEFINITION:END

**Usage:**

Releases all the memory //array// uses and destroys the array object.

The function always returns (parray*)NULL.
%FUNCTION:END
%NEED:20
%FUNCTION:BEGIN
=== parray_get ===[fn_parray_get]

**Definition:**

%DEFINITION:BEGIN
void* parray_get( parray* array, size_t offset )
%DEFINITION:END

**Usage:**

Access an element from the array by its offset position from the left.

//array// is the pointer to array where to access the element from.
//offset// is the offset of the element to be accessed from the array's
base address.

Returns the address of the accessed item, and NULL if the item could not
be accessed (e.g. if the array is empty or offset is beyond the top of array).

Use [parray_rget() #fn_parray_rget] for access items from the end.
%FUNCTION:END
%NEED:22
%FUNCTION:BEGIN
=== parray_init ===[fn_parray_init]

**Definition:**

%DEFINITION:BEGIN
void parray_init( parray* array, size_t size, size_t chunk )
%DEFINITION:END

**Usage:**

Performs an array initialization.

//array// is the pointer to the array to be initialized.

//size// defines the size of one array element, in bytes.
This should be evaluated using the [sizeof() #fn_sizeof]-macro.

//chunk// defines the chunk size, when an array-(re)allocation will be
performed. If, e.g. this is set to 128, then, if the 128th item is created
within the array, a realloction is done. Once allocated memory remains until
the array is freed again. The array's elements may change their heap address
when a chunk reallocation is required.
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== parray_insert ===[fn_parray_insert]

**Definition:**

%DEFINITION:BEGIN
void* parray_insert( parray* array, size_t offset, void* item )
%DEFINITION:END

**Usage:**

Insert item //item// at //offset// into array //array//.
Items right to //offset// will move up.

Gap space between the offset is filled with zero elements;
Handle with care!
%FUNCTION:END
%NEED:14
%FUNCTION:BEGIN
=== parray_iter ===[fn_parray_iter]

**Definition:**

%DEFINITION:BEGIN
void parray_iter( parray* array, parrayfn callback )
%DEFINITION:END

**Usage:**

Iterates over //array//.

Iterates over all items of //array// and calls the function //callback// on
every item.
%FUNCTION:END
%NEED:14
%FUNCTION:BEGIN
=== parray_last ===[fn_parray_last]

**Definition:**

%DEFINITION:BEGIN
void* parray_last( parray* array )
%DEFINITION:END

**Usage:**

Access last element of the array.

Returns the address of the accessed item, and NULL if nothing is in
the array.
%FUNCTION:END
%NEED:14
%FUNCTION:BEGIN
=== parray_malloc ===[fn_parray_malloc]

**Definition:**

%DEFINITION:BEGIN
void* parray_malloc( parray* array )
%DEFINITION:END

**Usage:**

Pushes and "allocates" an empty element on the array.

This function is just a shortcut to ```parray_push( array, NULL )```,
and the memory of the pushed element is initialized to zero.
%FUNCTION:END
%NEED:14
%FUNCTION:BEGIN
=== parray_next ===[fn_parray_next]

**Definition:**

%DEFINITION:BEGIN
void* parray_next( parray* array, void* ptr )
%DEFINITION:END

**Usage:**

Access next element from //ptr// in //array//.

Returns the address of the next element, and NULL if the access gets
out of bounds.
%FUNCTION:END
%NEED:17
%FUNCTION:BEGIN
=== parray_offset ===[fn_parray_offset]

**Definition:**

%DEFINITION:BEGIN
size_t parray_offset( parray* array, void* ptr )
%DEFINITION:END

**Usage:**

Return offset of element //ptr// in array //array//.

Returns the offset of //ptr// in //array//.
The function returns the size of the array (which is an invalid offset)
if //ptr// is not part of //array//.

To check if a pointer belongs to an array, call [parray_partof() #fn_parray_partof].
%FUNCTION:END
%NEED:11
%FUNCTION:BEGIN
=== parray_partof ===[fn_parray_partof]

**Definition:**

%DEFINITION:BEGIN
void* parray_partof( parray* array, void* ptr )
%DEFINITION:END

**Usage:**

Returns TRUE, if //ptr// is an element of array //array//.
%FUNCTION:END
%NEED:20
%FUNCTION:BEGIN
=== parray_pop ===[fn_parray_pop]

**Definition:**

%DEFINITION:BEGIN
void* parray_pop( parray* array )
%DEFINITION:END

**Usage:**

Removes an element from the end of an array.

The function returns the pointer of the popped item. Because dynamic arrays only
grow and no memory is freed, the returned data pointer is still valid, and will
only be overridden with the next push operation.

//array// is the pointer to array where to pop an item off.

The function returns the address of the popped item, and NULL if the
item could not be popped (e.g. array is empty).
%FUNCTION:END
%NEED:14
%FUNCTION:BEGIN
=== parray_prev ===[fn_parray_prev]

**Definition:**

%DEFINITION:BEGIN
void* parray_prev( parray* array, void* ptr )
%DEFINITION:END

**Usage:**

Access previous element from //ptr// in //array//.

Returns the address of the previous element, and NULL if the access gets
out of bounds.
%FUNCTION:END
%NEED:23
%FUNCTION:BEGIN
=== parray_push ===[fn_parray_push]

**Definition:**

%DEFINITION:BEGIN
void* parray_push( parray* array, void* item )
%DEFINITION:END

**Usage:**

Appends an element to the end of the array.

The element's memory is copied during the push. The item must be of the same
memory size as used at array initialization.

//array// is the pointer to array where to push an item on.

//item// is the pointer to the memory of the item that should be pushed onto the
array. The caller should cast his type into void, or wrap the push-operation
with a macro. It can be left NULL, so no memory will be copied.

The function returns the address of the newly pushed item, and NULL if
the item could not be pushed.
%FUNCTION:END
%NEED:20
%FUNCTION:BEGIN
=== parray_put ===[fn_parray_put]

**Definition:**

%DEFINITION:BEGIN
void* parray_put( parray* array, size_t offset, void* item )
%DEFINITION:END

**Usage:**

Put an element //item// at position //offset// of array //array//.

//array// is the pointer to array where to put the element to.
//offset// is the offset of the element to be set.
//item// is a pointer to the memory that will be copied into the
position at //offset//. If this is NULL, the position at //offset// will be
set to zero.

Returns the address of the item in the array, or NULL if the desired offset
is out of the array bounds.
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== parray_remove ===[fn_parray_remove]

**Definition:**

%DEFINITION:BEGIN
void* parray_remove( parray* array, size_t offset, void** item )
%DEFINITION:END

**Usage:**

Remove item on //offset// from array //array//.

The removed item will be copied into //item//, if //item// is not NULL.
The function returns the memory of the removed item (it will contain the
moved up data part or invalid memory, if on the end).
%FUNCTION:END
%NEED:14
%FUNCTION:BEGIN
=== parray_reserve ===[fn_parray_reserve]

**Definition:**

%DEFINITION:BEGIN
void* parray_reserve( parray* array, size_t n )
%DEFINITION:END

**Usage:**

Reserves memory for //n// items in //array//.

This function is only used to assume that no memory reallocation is done when
the next //n// items are inserted/malloced.
%FUNCTION:END
%NEED:21
%FUNCTION:BEGIN
=== parray_rget ===[fn_parray_rget]

**Definition:**

%DEFINITION:BEGIN
void* parray_rget( parray* array, size_t offset )
%DEFINITION:END

**Usage:**

Access an element from the array by its offset position from the right.

//array// is the pointer to array where to access the element from.
//offset// is the offset of the element to be accessed from the array's
base address.

Returns the address of the accessed item, and NULL if the item could not
be accessed (e.g. if the array is empty or offset is beyond the bottom of
the array).

Use [parray_get() #fn_parray_get] to access items from the begin.
%FUNCTION:END
%NEED:14
%FUNCTION:BEGIN
=== parray_riter ===[fn_parray_riter]

**Definition:**

%DEFINITION:BEGIN
void parray_riter( parray* array, parrayfn callback )
%DEFINITION:END

**Usage:**

Iterates backwards over //array//.

Backwardly iterates over all items of //array// and calls the function
//callback// on every item.
%FUNCTION:END
%NEED:14
%FUNCTION:BEGIN
=== parray_rmalloc ===[fn_parray_rmalloc]

**Definition:**

%DEFINITION:BEGIN
void* parray_rmalloc( parray* array )
%DEFINITION:END

**Usage:**

Unshifts and "allocates" an empty element on the array.

This function is just a shortcut to ```parray_unshift( array, NULL )```,
and the memory of the unshifted element is initialized to zero.
%FUNCTION:END
%NEED:21
%FUNCTION:BEGIN
=== parray_rput ===[fn_parray_rput]

**Definition:**

%DEFINITION:BEGIN
void* parray_rput( parray* array, size_t offset, void* item )
%DEFINITION:END

**Usage:**

Put an element //item// at position //offset// from the right of
array //array//.

//array// is the pointer to array where to put the element to.
//offset// is the offset of the element to be set.
//item// is a pointer to the memory that will be copied into the
position at //offset//. If this is NULL, the position at //offset// will be
set to zero.

Returns the address of the item in the array, or NULL if the desired offset
is out of the array bounds.
%FUNCTION:END
%NEED:14
%FUNCTION:BEGIN
=== parray_set_comparefn ===[fn_parray_set_comparefn]

**Definition:**

%DEFINITION:BEGIN
void parray_set_comparefn( parray* array, int (*comparefn)( parray*, void*, void* ) )
%DEFINITION:END

**Usage:**

Sets array compare function.

If no compare function is set or NULL is provided, [memcmp() #fn_memcmp] will be used
as default fallback.
%FUNCTION:END
%NEED:14
%FUNCTION:BEGIN
=== parray_set_sortfn ===[fn_parray_set_sortfn]

**Definition:**

%DEFINITION:BEGIN
void parray_set_sortfn( parray* array, int (*sortfn)( parray*, void*, void* ) )
%DEFINITION:END

**Usage:**

Sets array sort function.

If no sort function is given, the compare function set by [parray_set_comparefn() #fn_parray_set_comparefn]
is used. If even unset, [memcmp() #fn_memcmp] will be used.
%FUNCTION:END
%NEED:21
%FUNCTION:BEGIN
=== parray_shift ===[fn_parray_shift]

**Definition:**

%DEFINITION:BEGIN
void* parray_shift( parray* array )
%DEFINITION:END

**Usage:**

Removes an element from the begin of an array.

The function returns the pointer of the shifted item.
Because dynamic arrays only grow and no memory is freed, the returned data
pointer is still valid, and will only be overridden with the next unshift
operation.

//array// is the pointer to array where to pop an item off.

The function returns the address of the shifted item, and NULL if the
item could not be popped (e.g. array is empty).
%FUNCTION:END
%NEED:18
%FUNCTION:BEGIN
=== parray_sort ===[fn_parray_sort]

**Definition:**

%DEFINITION:BEGIN
void parray_sort( parray* array )
%DEFINITION:END

**Usage:**

Sorts //list// according to the sort-function that was set for the list.

To sort only parts of a list, use [plist_subsort() #fn_plist_subsort].

The sort-function can be modified by using [plist_set_sortfn() #fn_plist_set_sortfn].

The default sort function sorts the list by content using the [memcmp() #fn_memcmp]
standard function.
%FUNCTION:END
%NEED:19
%FUNCTION:BEGIN
=== parray_subsort ===[fn_parray_subsort]

**Definition:**

%DEFINITION:BEGIN
void parray_subsort( parray* array, size_t from, size_t to )
%DEFINITION:END

**Usage:**

Sorts //array// between the elements //from// and //to// according to the
sort-function that was set for the array.

To sort the entire array, use [parray_sort() #fn_parray_sort].

The sort-function can be modified by using [parray_set_sortfn() #fn_parray_set_sortfn].

The default sort function sorts the list by content using the [memcmp() #fn_memcmp]
standard function.
%FUNCTION:END
%NEED:11
%FUNCTION:BEGIN
=== parray_swap ===[fn_parray_swap]

**Definition:**

%DEFINITION:BEGIN
void* parray_swap( parray* array, size_t pos1, size_t pos2 )
%DEFINITION:END

**Usage:**

Swap two elements of an array.
%FUNCTION:END
%NEED:18
%FUNCTION:BEGIN
=== parray_union ===[fn_parray_union]

**Definition:**

%DEFINITION:BEGIN
size_t parray_union( parray* all, parray* from )
%DEFINITION:END

**Usage:**

Unions elements from array //from// into array //all//.

An element is only added to //all//, if there exists no equal element with the
same size and content.

The function will not run if both arrays have different element size settings.

The function returns the number of elements added to //from//.
%FUNCTION:END
%NEED:23
%FUNCTION:BEGIN
=== parray_unshift ===[fn_parray_unshift]

**Definition:**

%DEFINITION:BEGIN
void* parray_unshift( parray* array, void* item )
%DEFINITION:END

**Usage:**

Appends an element to the begin of the array.

The elements memory is copied during the unshift. The item must be of the same
memory size as used at array initialization.

//array// is the pointer to array where to push an item to the beginning.

//item// is the pointer to the memory of the item that should be pushed onto the
array. The caller should cast his type into void, or wrap the push-operation
with a macro. It can be left NULL, so no memory will be copied.

The function returns the address of the newly unshifted item, and NULL
if the item could not be unshifted.
%FUNCTION:END
%NEED:19
%FUNCTION:BEGIN
=== pasprintf ===[fn_pasprintf]

**Definition:**

%DEFINITION:BEGIN
char* pasprintf( char* fmt, ... )
%DEFINITION:END

**Usage:**

Implementation and replacement for asprintf. [pasprintf() #fn_pasprintf] takes only the
format-string and various arguments. It outputs an allocated string to be freed
later on.

//fmt// is the format string.
//...// are the parameters according to the placeholders set in //fmt//.

Returns a char* Returns the allocated string which contains the format string
with inserted values.
%FUNCTION:END
%NEED:21
%FUNCTION:BEGIN
=== pawcsprintf ===[fn_pawcsprintf]

**Definition:**

%DEFINITION:BEGIN
wchar_t* pawcsprintf( wchar_t* fmt, ... )
%DEFINITION:END

**Usage:**

An implementation of [pasprintf() #fn_pasprintf] for wide-character wchar_t. [pasprintf() #fn_pasprintf]
takes only the format-string and various arguments. It outputs an allocated
string to be released with [pfree() #fn_pfree] later on.

//fmt// is the format string.
//...// are the parameters according to the placeholders set in //fmt//.

Returns a wchar_t* Returns the allocated string which cointains the format
string with inserted values.

//This function is only available when compiled with -DUNICODE.//
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== pbasename ===[fn_pbasename]

**Definition:**

%DEFINITION:BEGIN
char* pbasename( char* path )
%DEFINITION:END

**Usage:**

Returns the basename of a file.

//path// is the file path pointer.

Returns a pointer to the basename, which is a part of //path//.
%FUNCTION:END
%NEED:16
%FUNCTION:BEGIN
=== pccl_add ===[fn_pccl_add]

**Definition:**

%DEFINITION:BEGIN
pboolean pccl_add( pccl* ccl, wchar_t ch )
%DEFINITION:END

**Usage:**

Integrates a single character into a character-class.

//ccl// is the pointer to the character-class to be affected.
//ch// is the character to be integrated.

The function is a shortcut for [pccl_addrange() #fn_pccl_addrange].
%FUNCTION:END
%NEED:19
%FUNCTION:BEGIN
=== pccl_addrange ===[fn_pccl_addrange]

**Definition:**

%DEFINITION:BEGIN
pboolean pccl_addrange( pccl* ccl, wchar_t begin, wchar_t end )
%DEFINITION:END

**Usage:**

Integrates a character range into a character-class.

//ccl// is the pointer to the character-class to be affected. If //ccl// is
provided as (pccl*)NULL, it will be created by the function.

//begin// is the begin of character range to be integrated.
//end// is the end of character range to be integrated.

If //begin// is greater than //end//, the values will be swapped.
%FUNCTION:END
%NEED:17
%FUNCTION:BEGIN
=== pccl_compare ===[fn_pccl_compare]

**Definition:**

%DEFINITION:BEGIN
int pccl_compare( pccl* left, pccl* right )
%DEFINITION:END

**Usage:**

Checks for differences in two character-classes.

//left// is the pointer to the first character-class.
//right// is the pointer to the second character-class.

Returns a value < 0 if //left// is lower than //right//, 0 if //left// is
equal to //right// or a value > 0 if //left// is greater than //right//.
%FUNCTION:END
%NEED:12
%FUNCTION:BEGIN
=== pccl_compat ===[fn_pccl_compat]

**Definition:**

%DEFINITION:BEGIN
pboolean pccl_compat( pccl* l, pccl* r )
%DEFINITION:END

**Usage:**

Checks if the character-classes //l// and //r// are configured
to be in the same character universe and compatible for operations.
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== pccl_count ===[fn_pccl_count]

**Definition:**

%DEFINITION:BEGIN
size_t pccl_count( pccl* ccl )
%DEFINITION:END

**Usage:**

Returns the number of characters within a character-class.

//ccl// is a pointer to the character-class to be processed.

Returns the total number of characters the class is holding.
%FUNCTION:END
%NEED:17
%FUNCTION:BEGIN
=== pccl_create ===[fn_pccl_create]

**Definition:**

%DEFINITION:BEGIN
pccl* pccl_create( int min, int max, char* ccldef )
%DEFINITION:END

**Usage:**

Constructor function to create a new character-class.

//min// and //max// can either be specified as -1, so the configured default
constants PCCL_MIN and PCCL_MAX will be used. The values can also be inverted.

Returns a pointer to the newly created character-class. This pointer should be
released with [pccl_free() #fn_pccl_free] when its existence is no longer required.
%FUNCTION:END
%NEED:16
%FUNCTION:BEGIN
=== pccl_del ===[fn_pccl_del]

**Definition:**

%DEFINITION:BEGIN
pboolean pccl_del( pccl* ccl, wchar_t ch )
%DEFINITION:END

**Usage:**

Removes a character from a character-class.

//ccl// is the pointer to the character-class to be affected.
//ch// is the character to be removed from //ccl//.

The function is a shortcut for [pccl_delrange() #fn_pccl_delrange].
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== pccl_delrange ===[fn_pccl_delrange]

**Definition:**

%DEFINITION:BEGIN
pboolean pccl_delrange( pccl* ccl, wchar_t begin, wchar_t end )
%DEFINITION:END

**Usage:**

Removes a character range from a character-class.

//ccl// is the pointer to the character-class to be affected.
//begin// is the begin of character range to be removed.
//end// is the end of character range to be removed.
%FUNCTION:END
%NEED:20
%FUNCTION:BEGIN
=== pccl_diff ===[fn_pccl_diff]

**Definition:**

%DEFINITION:BEGIN
pccl* pccl_diff( pccl* ccl, pccl* rem )
%DEFINITION:END

**Usage:**

Returns the difference quantity of two character-classes.
All elements from //rem// will be removed from //ccl//, and put into a
new character-class.

//ccl// is the pointer to the first character-class.
//rem// is the pointer to the second character-class.

Returns a new pointer to a copy of //ccl//, without the ranges contained in
//rem//. Returns (pccl*)NULL in case of memory allocation or parameter
error.
%FUNCTION:END
%NEED:16
%FUNCTION:BEGIN
=== pccl_dup ===[fn_pccl_dup]

**Definition:**

%DEFINITION:BEGIN
pccl* pccl_dup( pccl* ccl )
%DEFINITION:END

**Usage:**

Duplicates a character-class into a new one.

//ccl// is the pointer to the character-class to be duplicated.

Returns a pointer to the duplicate of //ccl//, or (pcrange)NULL
in error case.
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== pccl_erase ===[fn_pccl_erase]

**Definition:**

%DEFINITION:BEGIN
void pccl_erase( pccl* ccl )
%DEFINITION:END

**Usage:**

Erases a character-class //ccl//.

The function sets a character-class to zero, as it contains no character range
definitions. The object //ccl// will be still alive. To delete the entire
object, use [pccl_free() #fn_pccl_free].
%FUNCTION:END
%NEED:13
%FUNCTION:BEGIN
=== pccl_free ===[fn_pccl_free]

**Definition:**

%DEFINITION:BEGIN
pccl* pccl_free( pccl* ccl )
%DEFINITION:END

**Usage:**

Frees a character-class //ccl// and all its used memory.

The function always returns (pccl*)NULL.
%FUNCTION:END
%NEED:23
%FUNCTION:BEGIN
=== pccl_get ===[fn_pccl_get]

**Definition:**

%DEFINITION:BEGIN
pboolean pccl_get( wchar_t* from, wchar_t* to, pccl* ccl, size_t offset )
%DEFINITION:END

**Usage:**

Return a character or a character-range by its offset.

If the function is called only with pointer //from// provided, and //to// as
(wchar_t*)NULL, it writes the character in //offset//th position of the
character-class into from.

If the function is called both with pointer //from// and //to// provided,
it writes the //begin// and //end// character of the character-range in the
//offset//th position of the character-class into //from// and //to//.

If no character or range with the given offset was found, the function
returns FALSE, meaning that the end of the characters is reached.
On success, the function will always return TRUE.
%FUNCTION:END
%NEED:19
%FUNCTION:BEGIN
=== pccl_instest ===[fn_pccl_instest]

**Definition:**

%DEFINITION:BEGIN
pboolean pccl_instest( pccl* ccl, wchar_t ch )
%DEFINITION:END

**Usage:**

Tests for a character in case-insensitive-mode if it matches
a character-class.

//ccl// is the pointer to character-class to be tested.
//ch// is the character to be tested.

The function is a shortcut for [pccl_testrange() #fn_pccl_testrange].

It returns TRUE, if the character matches the class, and FALSE if not.
%FUNCTION:END
%NEED:19
%FUNCTION:BEGIN
=== pccl_intersect ===[fn_pccl_intersect]

**Definition:**

%DEFINITION:BEGIN
pccl* pccl_intersect( pccl* ccl, pccl* within )
%DEFINITION:END

**Usage:**

Returns a new character-class with all characters that exist in both
provided character-classes.

//ccl// is the pointer to the first character-class.
//within// is the pointer to the second character-class.

Returns a new character-class containing the intersection of //ccl//
and //within//. If there is no intersection between both character-classes,
the function returns (pccl*)NULL.
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== pccl_negate ===[fn_pccl_negate]

**Definition:**

%DEFINITION:BEGIN
pccl* pccl_negate( pccl* ccl )
%DEFINITION:END

**Usage:**

Negates all ranges in a character-class.

//ccl// is the pointer to the character-class to be negated.

Returns a pointer to //ccl//.
%FUNCTION:END
%NEED:29
%FUNCTION:BEGIN
=== pccl_parse ===[fn_pccl_parse]

**Definition:**

%DEFINITION:BEGIN
pccl* pccl_parse( pccl* ccl, char* ccldef, pboolean extend )
%DEFINITION:END

**Usage:**

Parses the character-class definition provided in //ccldef// and assigns
this definition to the character-class //ccl//.

If //ccl// is NULL, a new character-class with the PCCL_MIN/PCCL_MAX
configuration will be created.

//ccldef// may contain UTF-8 formatted input. Escape-sequences will be
interpreted to their correct character representations.

A typical character-class definition simply exists of single characters and
range definitions. For example, "$A-Z#0-9" defines a character-class that
consists of the characters "$#0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ".

The parameter //extend// specifies, if the provided character-class overwrites
(//extend// = FALSE) or extends (//extend// = TRUE) the provided
character-class. This means that definitions that already exist in the
character-class, should be erased first or not.

The function returns TRUE on success, and FALSE on an error.
%FUNCTION:END
%NEED:20
%FUNCTION:BEGIN
=== pccl_parsechar ===[fn_pccl_parsechar]

**Definition:**

%DEFINITION:BEGIN
size_t pccl_parsechar( wchar_t* retc, char *str, pboolean escapeseq )
%DEFINITION:END

**Usage:**

Reads a character from a string. The character may consist of one single
character or it may be made up of an escape sequence or UTF-8 character.
The function returns the number of bytes read.

//retc// is the return pointer for the character code of the escaped string.
//str// is the begin pointer of the string at which character parsing begins.
If //escapeseq// is TRUE, the function regards escape sequences, else it ignores
them.

Returns the number of bytes that had been read for the character.
%FUNCTION:END
%NEED:19
%FUNCTION:BEGIN
=== pccl_parseshorthand ===[fn_pccl_parseshorthand]

**Definition:**

%DEFINITION:BEGIN
pboolean pccl_parseshorthand( pccl* ccl, char** str )
%DEFINITION:END

**Usage:**

Tries to parse a shorthand sequence from a string. This matches the
shorthands \w, \W, \d, \D, \s and \S. If it matches, all characters are
added to //ccl//.

The function returns TRUE in case a shorthand has been parsed. If so,
the pointer //str// is moved the characters consumed.

If no shorthand sequence could be found, it returns FALSE, leaving //ccl//
untouched.
%FUNCTION:END
%NEED:22
%FUNCTION:BEGIN
=== pccl_print ===[fn_pccl_print]

**Definition:**

%DEFINITION:BEGIN
void pccl_print( FILE* stream, pccl* ccl, int break_after )
%DEFINITION:END

**Usage:**

Print character-class to output stream.
This function is provided for debug-purposes only.

//stream// is the output stream to dump the character-class to; This can be
left (FILE*)NULL, so //stderr// will be used.
//ccl// is the pointer to character-class

//break_after// defines:
- if < 0 print with pointer info
- if 0 print all into one line
- if > 0 print linewise
-
%FUNCTION:END
%NEED:17
%FUNCTION:BEGIN
=== pccl_size ===[fn_pccl_size]

**Definition:**

%DEFINITION:BEGIN
size_t pccl_size( pccl* ccl )
%DEFINITION:END

**Usage:**

Returns the number of range pairs within a character-class.

//ccl// is a pointer to the character-class to be processed.

To retrieve the number of characters in a character-class, use [pccl_count() #fn_pccl_count] instead.

Returns the number of pairs the charclass holds.
%FUNCTION:END
%NEED:18
%FUNCTION:BEGIN
=== pccl_test ===[fn_pccl_test]

**Definition:**

%DEFINITION:BEGIN
pboolean pccl_test( pccl* ccl, wchar_t ch )
%DEFINITION:END

**Usage:**

Tests a character-class if it contains a character.

//ccl// is the pointer to character-class to be tested.
//ch// is the character to be tested.

The function is a shortcut for [pccl_testrange() #fn_pccl_testrange].

It returns TRUE, if the character matches the class, and FALSE if not.
%FUNCTION:END
%NEED:17
%FUNCTION:BEGIN
=== pccl_testrange ===[fn_pccl_testrange]

**Definition:**

%DEFINITION:BEGIN
pboolean pccl_testrange( pccl* ccl, wchar_t begin, wchar_t end )
%DEFINITION:END

**Usage:**

Tests a character-class to match a character range.

//ccl// is a pointer to the character-class to be tested.
//begin// is the begin of character-range to be tested.
//end// is the end of character-range to be tested.

Returns TRUE if the entire character range matches the class, and FALSE if not.
%FUNCTION:END
%NEED:22
%FUNCTION:BEGIN
=== pccl_to_str ===[fn_pccl_to_str]

**Definition:**

%DEFINITION:BEGIN
char* pccl_to_str( pccl* ccl, pboolean escape )
%DEFINITION:END

**Usage:**

Converts a character-class back to a string representation of the
character-class definition, which in turn can be converted back into a
character-class using [pccl_create() #fn_pccl_create].

//ccl// is the pointer to character-class to be converted.
//escape//, if TRUE, escapes "unprintable" characters in their hexadecimal
representation. If FALSE, it prints all characters, except the zero, which will
be returned as "\0"

Returns a pointer to the generated string that represents the charclass.
The returned pointer belongs to the //ccl// and is managed by the
character-class handling functions, so it should not be freed manually.
%FUNCTION:END
%NEED:19
%FUNCTION:BEGIN
=== pccl_union ===[fn_pccl_union]

**Definition:**

%DEFINITION:BEGIN
pccl* pccl_union( pccl* ccl, pccl* add )
%DEFINITION:END

**Usage:**

Creates the union of two character-classes and returns the newly created,
normalized character-class.

//ccl// is the pointer to the character-class that will be extended to all
ranges contained in //add//. //add// is the character-class that will be joined
with //ccl//.

The function creates and returns a new character-class that is the union
of //ccl// and //add//.
%FUNCTION:END
%NEED:19
%FUNCTION:BEGIN
=== pdbl_to_str ===[fn_pdbl_to_str]

**Definition:**

%DEFINITION:BEGIN
char* pdbl_to_str( double d )
%DEFINITION:END

**Usage:**

Converts a double-value into an allocated string buffer.

//d// is the double value to become converted. Zero-digits behind the decimal
dot will be removed after conversion, so 1.65000 will become "1.65" in its
string representation.

Returns a pointer to the newly allocated string, which contains the
string-representation of the double value. This pointer must be released
by the caller.
%FUNCTION:END
%NEED:21
%FUNCTION:BEGIN
=== pdbl_to_wcs ===[fn_pdbl_to_wcs]

**Definition:**

%DEFINITION:BEGIN
wchar_t* pdbl_to_wcs( double d )
%DEFINITION:END

**Usage:**

Converts a double-value into an allocated wide-character string buffer.

//d// is the double value to become converted. Zero-digits behind the decimal
dot will be removed after conversion, so 1.65000 will become L"1.65" in its
wide-character string representation.

Returns a pointer to the newly allocated wide-character string, which contains
the string-representation of the double value. This pointer must be released
by the caller.

//This function is only available when compiled with -DUNICODE.//
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== pfileexists ===[fn_pfileexists]

**Definition:**

%DEFINITION:BEGIN
pboolean pfileexists( char* filename )
%DEFINITION:END

**Usage:**

Checks for file existence.

//filename// is the path to a file that will be checked.

Returns TRUE on success, FALSE if not.
%FUNCTION:END
%NEED:16
%FUNCTION:BEGIN
=== pfiletostr ===[fn_pfiletostr]

**Definition:**

%DEFINITION:BEGIN
pboolean pfiletostr( char** cont, char* filename )
%DEFINITION:END

**Usage:**

Maps the content of an entire file into memory.

//cont// is the file content return pointer.
//filename// is the path to file to be mapped

The function returns TRUE on success.
%FUNCTION:END
%NEED:22
%FUNCTION:BEGIN
=== pfree ===[fn_pfree]

**Definition:**

%DEFINITION:BEGIN
void* pfree( void* ptr )
%DEFINITION:END

**Usage:**

Free allocated memory.

The function is a wrapper for the system-function [free() #fn_free], but accepts
NULL-pointers and returns a (void*)NULL pointer for direct pointer memory reset.

It could be used this way to immediately reset a pointer to NULL:

``` ptr = pfree( ptr );

//ptr// is the pointer to be freed.

Always returns (void*)NULL.
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== pgetline ===[fn_pgetline]

**Definition:**

%DEFINITION:BEGIN
size_t pgetline( char** lineptr, size_t* n, FILE* stream )
%DEFINITION:END

**Usage:**

Reads an entire line from //stream//, storing the address of the buffer
containing the text into //lineptr//. The buffer is zero-terminated and
includes the newline character, if one was found.

This function serves as a platform-independent implementation for POSIX [getline() #fn_getline], which is wrapped in case of POSIX.
%FUNCTION:END
%NEED:74
%FUNCTION:BEGIN
=== pgetopt ===[fn_pgetopt]

**Definition:**

%DEFINITION:BEGIN
int pgetopt( char* opt, char** param, int* next, int argc, char** argv, char* optstr, char* loptstr, int idx )
%DEFINITION:END

**Usage:**

Command-line option interpreter.

This function works similar to the [getopt() #fn_getopt] functions of the GNU Standard
Library, but uses a different style of parameter submit.

It supports both short- and long- option-style parameters.

- //opt// is a pointer to a buffer with enough space to store the requested parameter to. For short parameters, this is only one char, for long-parameters the full name. The string will be zero-terminated.
- //param// is a pointer to store a possible parameter value to, if the detected option allows for parameters.
- //next// receives the index in argv of the next evaluated option. It can be left (int*)NULL. It points to the next valid index in argv[] after all parameters have been evaluated. Check it for < argc, to point to valid data.
- //argc// is the argument count as taken from the [main() #fn_main] function.
- //argv// are the argument values as taken from the [main() #fn_main] function.
- //optstr// contains the possible short-options. This is a string where each character defines an option. If an option takes a parameter, a colon (:) is submitted. E.g. "abc:def:g". The Options "-c" and "-f" will take a parameter that is
returned to param. This parameter can be (char*)NULL.
- //loptstr// contains the possible long-options. This is a string containing all long option names, each separated by a blank. Long options taking parameters have an attached colon (:) to the name.  E.g. "hello world: next" defines three long options, where option 'world' takes one parameter that is returned to param. This parameter can be (char*)NULL.
- //idx// is the index of the requested option, 0 for the first option behind argv[0].
-

The function must be called multiple times to read all command-line parameters
and to react on the parameters.

The function returns 0, if the parameter with the given index was
successfully evaluated. It returns 1, if there are still command-line
parameters, but not as part of options. The parameter //param// will receive
the given pointer. It returns -1 if no more options could be read, or if an
option could not be evaluated (unknown option). In such case, //param// will
hold a string to the option that is unknown to [pgetopt() #fn_pgetopt].

**Example:**

This is a minimal example showing the usage of [pgetopt() #fn_pgetopt] in a real program:

```
#include <phorward.h>

int main( int argc, char** argv )
{
    int			i;
    int			rc;
    int			next;
    char		opt			[ 10 + 1 ];
    char*		param;

    for( i = 0; ( rc = pgetopt( opt, &param, &next, argc, argv,
                                "ho:", "help output:", i ) ) == 0; i++ )
    {
        if( !strcmp( opt, "help" ) || !strcmp( opt, "h" ) )
            printf( "Help\n" );
        else if( !strcmp( opt, "output" ) || !strcmp( opt, "o" ) )
            printf( "Output = >%s<\n", param );
    }

    if( rc < 0 && param )
    {
        fprintf( stderr, "Unknown option '%s'\n", param );
        return 1;
    }

    for( i = 0; next < argc; next++, i++ )
        printf( "Parameter %d = >%s<\n", i, argv[ next ] );

    return 0;
}
```
%FUNCTION:END
%NEED:32
%FUNCTION:BEGIN
=== plex_create ===[fn_plex_create]

**Definition:**

%DEFINITION:BEGIN
plex* plex_create( int flags )
%DEFINITION:END

**Usage:**

Constructor function to create a new plex object.

//flags// can be a combination of compile- and runtime-flags and are merged
with special compile-time flags provided for each pattern.

|| Flag | Usage |
| PREGEX_COMP_WCHAR | The regular expressions are provided as wchar_t. |
| PREGEX_COMP_NOANCHORS | Ignore anchor tokens, handle them as normal characters |
| PREGEX_COMP_NOREF | Don't compile references. |
| PREGEX_COMP_NONGREEDY | Compile all patterns to be forced nongreedy. |
| PREGEX_COMP_NOERRORS | Don't report errors, and try to compile as much as possible |
| PREGEX_COMP_INSENSITIVE | Parse regular expressions as case insensitive. |
| PREGEX_COMP_STATIC | The regular expressions passed should be converted 1:1 as if it were a string-constant. Any regex-specific symbols will be ignored and taken as if escaped. |
| PREGEX_RUN_WCHAR | Run regular expressions with wchar_t as input. |
| PREGEX_RUN_NOANCHORS | Ignore anchors while processing the lexer. |
| PREGEX_RUN_NOREF | Don't create references. |
| PREGEX_RUN_NONGREEDY | Force run lexer nongreedy. |
| PREGEX_RUN_DEBUG | Debug mode; output some debug info to stderr. |


On success, the function returns the allocated pointer to a plex-object.
This must be freed later using [plex_free() #fn_plex_free].
%FUNCTION:END
%NEED:36
%FUNCTION:BEGIN
=== plex_define ===[fn_plex_define]

**Definition:**

%DEFINITION:BEGIN
pregex_ptn* plex_define( plex* lex, char* pat, int match_id, int flags )
%DEFINITION:END

**Usage:**

Defines and parses a regular expression pattern into the plex-object.

//pat// is the regular expression string, or a pointer to a pregex_ptn*
structure in case PREGEX_COMP_PTN is flagged.

//match_id// must be a token match ID, a value > 0. The lower the match ID is,
the higher precedence takes the appended expression when there are multiple
matches.

//flags// may ONLY contain compile-time flags, and is combined with the
compile-time flags of the plex-object provided at [plex_create() #fn_plex_create].

|| Flag | Usage |
| PREGEX_COMP_WCHAR | The regular expressions are provided as wchar_t. |
| PREGEX_COMP_NOANCHORS | Ignore anchor tokens, handle them as normal characters |
| PREGEX_COMP_NOREF | Don't compile references. |
| PREGEX_COMP_NONGREEDY | Compile all patterns to be forced nongreedy. |
| PREGEX_COMP_NOERRORS | Don't report errors, and try to compile as much as possible |
| PREGEX_COMP_INSENSITIVE | Parse regular expressions as case insensitive. |
| PREGEX_COMP_STATIC | The regular expressions passed should be converted 1:1 as if it were a string-constant. Any regex-specific symbols will be ignored and taken as if escaped. |
| PREGEX_COMP_PTN | The regular expression passed already is a pattern, and shall be integrated. |


Returns a pointer to the pattern object that just has been added. This allows
for changing e.g. the accept flag later on. In case of an error, the value
returned is NULL.
%FUNCTION:END
%NEED:19
%FUNCTION:BEGIN
=== plex_dump_dot ===[fn_plex_dump_dot]

**Definition:**

%DEFINITION:BEGIN
void plex_dump_dot( FILE* stream, plex* lex )
%DEFINITION:END

**Usage:**

Dumps the DFA of a //lex// lexer object into a DOT-formatted graph output.

The graph can be made visible with tools like Graphviz
(http://www.graphviz.org/) and similar.

//stream// is the output stream to be used. This is stdout when NULL is
provided.

//lex// is the plex object, which DFA shall be dumped.
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== plex_free ===[fn_plex_free]

**Definition:**

%DEFINITION:BEGIN
plex* plex_free( plex* lex )
%DEFINITION:END

**Usage:**

Destructor function for a plex-object.

//lex// is the pointer to a plex-structure that will be released.

Always returns (plex*)NULL.
%FUNCTION:END
%NEED:18
%FUNCTION:BEGIN
=== plex_lex ===[fn_plex_lex]

**Definition:**

%DEFINITION:BEGIN
int plex_lex( plex* lex, char* start, char** end )
%DEFINITION:END

**Usage:**

Performs a lexical analysis using the object //lex// on pointer //start//.

If a token can be matched, the function returns the related id of the matching
pattern, and //end// receives the pointer to the last matched character.

The function returns 0 in case that there was no direct match.
The function [plex_next() #fn_plex_next] ignores unrecognized symbols and directly moves to the
next matching pattern.
%FUNCTION:END
%NEED:22
%FUNCTION:BEGIN
=== plex_next ===[fn_plex_next]

**Definition:**

%DEFINITION:BEGIN
char* plex_next( plex* lex, char* start, unsigned int* id, char** end )
%DEFINITION:END

**Usage:**

Performs lexical analysis using //lex// from begin of pointer //start//, to
the next matching token.

//start// has to be a zero-terminated string or wide-character string (according
to the configuration of the plex-object).

If a token can be matched, the function returns the pointer to the position
where the match starts at. //id// receives the id of the matching pattern,
//end// receives the end pointer of the match, when provided. //id// and //end//
can be omitted by providing NULL-pointers.

The function returns (char*)NULL in case that there is no match.
%FUNCTION:END
%NEED:11
%FUNCTION:BEGIN
=== plex_prepare ===[fn_plex_prepare]

**Definition:**

%DEFINITION:BEGIN
pboolean plex_prepare( plex* lex )
%DEFINITION:END

**Usage:**

Prepares the DFA state machine of a plex-object //lex// for execution.
%FUNCTION:END
%NEED:11
%FUNCTION:BEGIN
=== plex_reset ===[fn_plex_reset]

**Definition:**

%DEFINITION:BEGIN
pboolean plex_reset( plex* lex )
%DEFINITION:END

**Usage:**

Resets the DFA state machine of a plex-object //lex//.
%FUNCTION:END
%NEED:18
%FUNCTION:BEGIN
=== plex_tokenize ===[fn_plex_tokenize]

**Definition:**

%DEFINITION:BEGIN
size_t plex_tokenize( plex* lex, char* start, parray** matches )
%DEFINITION:END

**Usage:**

Tokenizes the string beginning at //start// using the lexical analyzer
//lex//.

//start// has to be a zero-terminated string or wide-character string (according
to the configuration of the plex-object).

The function initializes and fills the array //matches//, if provided, with
items of size prange. It returns the total number of matches.
%FUNCTION:END
%NEED:14
%FUNCTION:BEGIN
=== plexctx_create ===[fn_plexctx_create]

**Definition:**

%DEFINITION:BEGIN
plexctx* plexctx_create( plex* lex )
%DEFINITION:END

**Usage:**

Creates a new lexer context for lexer //par//.

lexer contexts are objects holding state and semantics information on a
current parsing process.
%FUNCTION:END
%NEED:11
%FUNCTION:BEGIN
=== plexctx_free ===[fn_plexctx_free]

**Definition:**

%DEFINITION:BEGIN
plexctx* plexctx_free( plexctx* ctx )
%DEFINITION:END

**Usage:**

Frees the lexer context object //ctx//.
%FUNCTION:END
%NEED:14
%FUNCTION:BEGIN
=== plexctx_init ===[fn_plexctx_init]

**Definition:**

%DEFINITION:BEGIN
plexctx* plexctx_init( plexctx* ctx, plex* lex )
%DEFINITION:END

**Usage:**

Initializes a lexer context //ctx// for lexer //lex//.

Lexer contexts are objects holding state and semantics information on a current
lexing process.
%FUNCTION:END
%NEED:12
%FUNCTION:BEGIN
=== plexctx_lex ===[fn_plexctx_lex]

**Definition:**

%DEFINITION:BEGIN
pboolean plexctx_lex( plexctx* ctx, wchar_t ch )
%DEFINITION:END

**Usage:**

Performs a lexical analysis using the object //lex// using context //ctx//
and character //ch//.
%FUNCTION:END
%NEED:11
%FUNCTION:BEGIN
=== plexctx_reset ===[fn_plexctx_reset]

**Definition:**

%DEFINITION:BEGIN
plexctx* plexctx_reset( plexctx* ctx )
%DEFINITION:END

**Usage:**

Resets the lexer context object //ctx//.
%FUNCTION:END
%NEED:11
%FUNCTION:BEGIN
=== plist_access ===[fn_plist_access]

**Definition:**

%DEFINITION:BEGIN
void* plist_access( plistel* e )
%DEFINITION:END

**Usage:**

Access data-content of the current element //e//.
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== plist_clear ===[fn_plist_clear]

**Definition:**

%DEFINITION:BEGIN
void plist_clear( plist* list )
%DEFINITION:END

**Usage:**

Clear content of the list //list//.

The function has nearly the same purpose as [plist_erase() #fn_plist_erase], except that
the entire list is only cleared, but if the list was initialized with
PLIST_MOD_RECYCLE, existing pointers are held for later usage.
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== plist_concat ===[fn_plist_concat]

**Definition:**

%DEFINITION:BEGIN
size_t plist_concat( plist* dest, plist* src )
%DEFINITION:END

**Usage:**

Concats the elements of list //src// to the elements of list //dest//.

The function will not run if both lists have different element size settings.

The function returns the number of elements added to //dest//.
%FUNCTION:END
%NEED:11
%FUNCTION:BEGIN
=== plist_count ===[fn_plist_count]

**Definition:**

%DEFINITION:BEGIN
size_t plist_count( plist* l )
%DEFINITION:END

**Usage:**

Return element count of list //l//.
%FUNCTION:END
%NEED:30
%FUNCTION:BEGIN
=== plist_create ===[fn_plist_create]

**Definition:**

%DEFINITION:BEGIN
plist* plist_create( size_t size, short flags )
%DEFINITION:END

**Usage:**

Create a new plist as an object with an element allocation size //size//.
Providing a //size// of 0 causes automatic configuration of PLIST_MOD_PTR.

//flags// defines an optional flag configuration that modifies the behavior
of the linked list and hash table usage. The flags can be merged together using
bitwise or (|).

Possible flags are:
- **PLIST_MOD_NONE** for no special flagging.
- **PLIST_MOD_PTR** to use the plist-object in pointer-mode: Each plistel-element cointains only a pointer to an object in the memory and returns this, instead of copying from or into pointers.
- **PLIST_MOD_RECYCLE** to configure that elements that are removed during list usage will be reused later.
- **PLIST_MOD_AUTOSORT** to automatically sort elements on insert operations.
- **PLIST_MOD_EXTKEYS** to configure that string pointers to hash-table keyvalues are stored elsewhere, so the plist-module only uses the original pointers instead of copying them.
- **PLIST_MOD_PTRKEYS** disables string keys and uses the pointer/value provided as key directly.
- **PLIST_MOD_KEEPKEYS** holds the correct element insertation sequence. In case of a key collision, the inserted element is inserted __behind__ the colliding element rather than __before__.
- **PLIST_MOD_UNIQUE** to disallow hash-table-key collisions, so elements with a key that already exist in the object will be rejected.
- **PLIST_MOD_WCHAR** to handle all key values as wide-character strings.
-

Use [plist_free() #fn_plist_free] to erase and release the returned list object.
%FUNCTION:END
%NEED:11
%FUNCTION:BEGIN
=== plist_dbgstats ===[fn_plist_dbgstats]

**Definition:**

%DEFINITION:BEGIN
void plist_dbgstats( FILE* stream, plist* list )
%DEFINITION:END

**Usage:**

Prints some statistics for the hashmap in //list// on stderr.
%FUNCTION:END
%NEED:16
%FUNCTION:BEGIN
=== plist_diff ===[fn_plist_diff]

**Definition:**

%DEFINITION:BEGIN
int plist_diff( plist* left, plist* right )
%DEFINITION:END

**Usage:**

Tests the contents (data parts) of the list //left// and the list //right//
for equal elements.

The function returns a value < 0 if //left// is lower //right//, a value > 0
if //left// is greater //right// and a value == 0 if //left// is equal to
//right//.
%FUNCTION:END
%NEED:13
%FUNCTION:BEGIN
=== plist_dup ===[fn_plist_dup]

**Definition:**

%DEFINITION:BEGIN
plist* plist_dup( plist* list )
%DEFINITION:END

**Usage:**

Creates an independent copy of //list// and returns it.

All elements of //list// are duplicated and stand-alone.
%FUNCTION:END
%NEED:14
%FUNCTION:BEGIN
=== plist_erase ===[fn_plist_erase]

**Definition:**

%DEFINITION:BEGIN
void plist_erase( plist* list )
%DEFINITION:END

**Usage:**

Erase all allocated content of the list //list//.

The object //list// will be still alive, but must be re-configured
using [plist_init() #fn_plist_init].
%FUNCTION:END
%NEED:11
%FUNCTION:BEGIN
=== plist_first ===[fn_plist_first]

**Definition:**

%DEFINITION:BEGIN
plistel* plist_first( plist* l )
%DEFINITION:END

**Usage:**

Return first element of list //l//.
%FUNCTION:END
%NEED:13
%FUNCTION:BEGIN
=== plist_free ===[fn_plist_free]

**Definition:**

%DEFINITION:BEGIN
plist* plist_free( plist* list )
%DEFINITION:END

**Usage:**

Releases all the memory //list// uses and destroys the list object.

The function always returns (plist*)NULL.
%FUNCTION:END
%NEED:13
%FUNCTION:BEGIN
=== plist_get ===[fn_plist_get]

**Definition:**

%DEFINITION:BEGIN
plistel* plist_get( plist* list, size_t n )
%DEFINITION:END

**Usage:**

Retrieve list element by its index from the begin.

The function returns the //n//th element of the list //list//.
%FUNCTION:END
%NEED:14
%FUNCTION:BEGIN
=== plist_get_by_key ===[fn_plist_get_by_key]

**Definition:**

%DEFINITION:BEGIN
plistel* plist_get_by_key( plist* list, char* key )
%DEFINITION:END

**Usage:**

Retrieve list element by hash-table //key//.

This function tries to fetch a list entry plistel from list //list//
with the key //key//.
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== plist_get_by_nkey ===[fn_plist_get_by_nkey]

**Definition:**

%DEFINITION:BEGIN
plistel* plist_get_by_nkey( plist* list, char* key, size_t n )
%DEFINITION:END

**Usage:**

Retrieve list element by hash-table //key//,
where key is limited by //n// bytes.

This function tries to fetch a list entry plistel from list //list//
with the key //key// over a size of //n// bytes.
%FUNCTION:END
%NEED:14
%FUNCTION:BEGIN
=== plist_get_by_ptr ===[fn_plist_get_by_ptr]

**Definition:**

%DEFINITION:BEGIN
plistel* plist_get_by_ptr( plist* list, void* ptr )
%DEFINITION:END

**Usage:**

Retrieve list element by pointer.

This function returns the list element of the unit within the list //list//
that is the pointer //ptr//.
%FUNCTION:END
%NEED:13
%FUNCTION:BEGIN
=== plist_getkey ===[fn_plist_getkey]

**Definition:**

%DEFINITION:BEGIN
plistel* plist_getkey( plist* list, size_t n )
%DEFINITION:END

**Usage:**

Retrieve list keys by their index from the begin.

The function returns the //n//th key within the list //list//.
%FUNCTION:END
%NEED:11
%FUNCTION:BEGIN
=== plist_hashnext ===[fn_plist_hashnext]

**Definition:**

%DEFINITION:BEGIN
plistel* plist_hashnext( plistel* u )
%DEFINITION:END

**Usage:**

Access next element with same hash value of current unit //u//.
%FUNCTION:END
%NEED:11
%FUNCTION:BEGIN
=== plist_hashprev ===[fn_plist_hashprev]

**Definition:**

%DEFINITION:BEGIN
plistel* plist_hashprev( plistel* u )
%DEFINITION:END

**Usage:**

Access previous element with same hash value of a current unit //u//.
%FUNCTION:END
%NEED:14
%FUNCTION:BEGIN
=== plist_init ===[fn_plist_init]

**Definition:**

%DEFINITION:BEGIN
void plist_init( plist* list, size_t size, short flags )
%DEFINITION:END

**Usage:**

Initialize the list //list// with an element allocation size //size//.

//flags// defines an optional flag configuration that modifies the behavior
of the linked list and hash table usage.
%FUNCTION:END
%NEED:19
%FUNCTION:BEGIN
=== plist_insert ===[fn_plist_insert]

**Definition:**

%DEFINITION:BEGIN
plistel* plist_insert( plist* list, plistel* pos, char* key, void* src )
%DEFINITION:END

**Usage:**

Insert //src// as element to the list //list// __before__ position //pos//.

If //pos// is NULL, the new element will be attached to the end of the
list.

If //key// is not NULL, the element will also be added to the lists hash table.

If //src// is NULL, a zero-initialized element is inserted into the list for
further processing.
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== plist_iter ===[fn_plist_iter]

**Definition:**

%DEFINITION:BEGIN
void plist_iter( plist* list, plistelfn callback )
%DEFINITION:END

**Usage:**

Iterates over //list//.

Iterates over all items of //list// and calls the function //callback// on
every item. The callback function receives the plistel-element pointer of
the list element.
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== plist_iter_access ===[fn_plist_iter_access]

**Definition:**

%DEFINITION:BEGIN
void plist_iter_access( plist* list, plistfn callback )
%DEFINITION:END

**Usage:**

Iterates over //list// and accesses every item.

Iterates over all items of //list// and calls the function //callback// on
every item's access. The callback function receives a pointer to the accessed
element.
%FUNCTION:END
%NEED:11
%FUNCTION:BEGIN
=== plist_key ===[fn_plist_key]

**Definition:**

%DEFINITION:BEGIN
char* plist_key( plistel* e )
%DEFINITION:END

**Usage:**

Access key-content of the current element //e//.
%FUNCTION:END
%NEED:11
%FUNCTION:BEGIN
=== plist_last ===[fn_plist_last]

**Definition:**

%DEFINITION:BEGIN
plistel* plist_last( plist* l )
%DEFINITION:END

**Usage:**

Return last element of list //l//.
%FUNCTION:END
%NEED:14
%FUNCTION:BEGIN
=== plist_malloc ===[fn_plist_malloc]

**Definition:**

%DEFINITION:BEGIN
void* plist_malloc( plist* list )
%DEFINITION:END

**Usage:**

Allocates memory for a new element in list //list//, push it to the end and
return the pointer to this.

The function works as a shortcut for [plist_access() #fn_plist_access] in combination with [plist_push() #fn_plist_push].
%FUNCTION:END
%NEED:11
%FUNCTION:BEGIN
=== plist_next ===[fn_plist_next]

**Definition:**

%DEFINITION:BEGIN
plistel* plist_next( plistel* u )
%DEFINITION:END

**Usage:**

Access next element of current unit //u//.
%FUNCTION:END
%NEED:11
%FUNCTION:BEGIN
=== plist_offset ===[fn_plist_offset]

**Definition:**

%DEFINITION:BEGIN
int plist_offset( plistel* u )
%DEFINITION:END

**Usage:**

Return the offset of the unit //u// within the list it belongs to.
%FUNCTION:END
%NEED:17
%FUNCTION:BEGIN
=== plist_pop ===[fn_plist_pop]

**Definition:**

%DEFINITION:BEGIN
pboolean plist_pop( plist* list, void* dest )
%DEFINITION:END

**Usage:**

Pop last element to //dest// off the list //list//.

Like //list// would be a stack, the last element of the list is popped and
its content is written to //dest//, if provided at the end of the list.

//dest// can be omitted and given as (void*)NULL, so the last element will
be popped off the list and discards.
%FUNCTION:END
%NEED:11
%FUNCTION:BEGIN
=== plist_prev ===[fn_plist_prev]

**Definition:**

%DEFINITION:BEGIN
plistel* plist_prev( plistel* u )
%DEFINITION:END

**Usage:**

Access previous element of current unit //u//.
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== plist_push ===[fn_plist_push]

**Definition:**

%DEFINITION:BEGIN
plistel* plist_push( plist* list, void* src )
%DEFINITION:END

**Usage:**

Push //src// to end of //list//.

Like //list// would be a stack, //src// is pushed at the end of the list.
This function can only be used for linked lists without the hash-table feature
in use.
%FUNCTION:END
%NEED:12
%FUNCTION:BEGIN
=== plist_remove ===[fn_plist_remove]

**Definition:**

%DEFINITION:BEGIN
void plist_remove( plist* list, plistel* e )
%DEFINITION:END

**Usage:**

Removes the element //e// from the //list// and frees it or puts
it into the unused element chain if PLIST_MOD_RECYCLE is flagged.
%FUNCTION:END
%NEED:14
%FUNCTION:BEGIN
=== plist_rget ===[fn_plist_rget]

**Definition:**

%DEFINITION:BEGIN
plistel* plist_rget( plist* list, size_t n )
%DEFINITION:END

**Usage:**

Retrieve list element by its index from the end.

The function returns the //n//th element of the list //list//
from the right.
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== plist_riter ===[fn_plist_riter]

**Definition:**

%DEFINITION:BEGIN
void plist_riter( plist* list, plistelfn callback )
%DEFINITION:END

**Usage:**

Iterates backwards over //list//.

Backwardly iterates over all items of //list// and calls the function
//callback// on every item. The callback function receives the plistel-element
pointer of the list element.
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== plist_riter_access ===[fn_plist_riter_access]

**Definition:**

%DEFINITION:BEGIN
void plist_riter_access( plist* list, plistfn callback )
%DEFINITION:END

**Usage:**

Iterates backwards over //list//.

Backwardly iterates over all items of //list// and calls the function
//callback// on every  item's access. The callback function receives a pointer
to the accessed element.
%FUNCTION:END
%NEED:14
%FUNCTION:BEGIN
=== plist_rmalloc ===[fn_plist_rmalloc]

**Definition:**

%DEFINITION:BEGIN
void* plist_rmalloc( plist* list )
%DEFINITION:END

**Usage:**

Allocates memory for a new element in list //list//, shift it at the begin
and return the pointer to this.

The function works as a shortcut for [plist_access() #fn_plist_access] in combination with [plist_shift() #fn_plist_shift].
%FUNCTION:END
%NEED:14
%FUNCTION:BEGIN
=== plist_set_comparefn ===[fn_plist_set_comparefn]

**Definition:**

%DEFINITION:BEGIN
void plist_set_comparefn( plist* list, int (*comparefn)( plist*, plistel*, plistel* ) )
%DEFINITION:END

**Usage:**

Set compare function.

If no compare function is set or NULL is provided, [memcmp() #fn_memcmp] will be used
as default fallback.
%FUNCTION:END
%NEED:11
%FUNCTION:BEGIN
=== plist_set_printfn ===[fn_plist_set_printfn]

**Definition:**

%DEFINITION:BEGIN
void plist_set_printfn( plist* list, void (*printfn)( plist* ) )
%DEFINITION:END

**Usage:**

Set an element dump function.
%FUNCTION:END
%NEED:14
%FUNCTION:BEGIN
=== plist_set_sortfn ===[fn_plist_set_sortfn]

**Definition:**

%DEFINITION:BEGIN
void plist_set_sortfn( plist* list, int (*sortfn)( plist*, plistel*, plistel* ) )
%DEFINITION:END

**Usage:**

Set sort function.

If no sort function is given, the compare function set by [plist_set_comparefn() #fn_plist_set_comparefn]
is used. If even unset, [memcmp() #fn_memcmp] will be used.
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== plist_shift ===[fn_plist_shift]

**Definition:**

%DEFINITION:BEGIN
plistel* plist_shift( plist* list, void* src )
%DEFINITION:END

**Usage:**

Shift //src// at begin of //list//.

Like //list// would be a queue, //src// is shifted at the beginning of the list.
This function can only be used for linked lists without the hash-table feature
in use.
%FUNCTION:END
%NEED:11
%FUNCTION:BEGIN
=== plist_size ===[fn_plist_size]

**Definition:**

%DEFINITION:BEGIN
int plist_size( plist* l )
%DEFINITION:END

**Usage:**

Return element size of list //l//.
%FUNCTION:END
%NEED:18
%FUNCTION:BEGIN
=== plist_sort ===[fn_plist_sort]

**Definition:**

%DEFINITION:BEGIN
void plist_sort( plist* list )
%DEFINITION:END

**Usage:**

Sorts //list// according to the sort-function that was set for the list.

To sort only parts of a list, use [plist_subsort() #fn_plist_subsort].

The sort-function can be modified by using [plist_set_sortfn() #fn_plist_set_sortfn].

The default sort function sorts the list by content using the [memcmp() #fn_memcmp]
standard function.
%FUNCTION:END
%NEED:19
%FUNCTION:BEGIN
=== plist_subsort ===[fn_plist_subsort]

**Definition:**

%DEFINITION:BEGIN
void plist_subsort( plist* list, plistel* left, plistel* right )
%DEFINITION:END

**Usage:**

Sorts //list// between the elements //left// and //right// according to the
sort-function that was set for the list.

To sort the entire list, use [plist_sort() #fn_plist_sort].

The sort-function can be modified by using [plist_set_sortfn() #fn_plist_set_sortfn].

The default sort function sorts the list by content using the [memcmp() #fn_memcmp]
standard function.
%FUNCTION:END
%NEED:13
%FUNCTION:BEGIN
=== plist_swap ===[fn_plist_swap]

**Definition:**

%DEFINITION:BEGIN
void plist_swap( plist* l, plistel* a, plistel* b )
%DEFINITION:END

**Usage:**

Swaps the positions of the list elements //a// and //b// with each
other. The elements must be in the same plist object, else the function
returns FALSE.
%FUNCTION:END
%NEED:18
%FUNCTION:BEGIN
=== plist_union ===[fn_plist_union]

**Definition:**

%DEFINITION:BEGIN
size_t plist_union( plist* all, plist* from )
%DEFINITION:END

**Usage:**

Unions elements from list //from// into list //all//.

An element is only added to //all//, if there exists no equal element with the
same size and content.

The function will not run if both lists have different element size settings.

The function returns the number of elements added to //from//.
%FUNCTION:END
%NEED:17
%FUNCTION:BEGIN
=== plist_unshift ===[fn_plist_unshift]

**Definition:**

%DEFINITION:BEGIN
pboolean plist_unshift( plist* list, void* dest )
%DEFINITION:END

**Usage:**

Take first element of //list// and write it to //dest//.

Like //list// would be a queue, the first element of the list is taken and
its content is written to //dest//.

//dest// can be omitted and given as (void*)NULL, so the first element from
//list// will be taken and discarded.
%FUNCTION:END
%NEED:20
%FUNCTION:BEGIN
=== pmalloc ===[fn_pmalloc]

**Definition:**

%DEFINITION:BEGIN
void* pmalloc( size_t size )
%DEFINITION:END

**Usage:**

Dynamically allocate heap memory.

The function is a wrapper for the system function [malloc() #fn_malloc], but with memory
initialization to zero, and immediately stops the program if no more memory
can be allocated.

//size// is the size of memory to be allocated, in bytes.

The function returns the allocated heap memory pointer. The returned memory
address should be freed using [pfree() #fn_pfree] after it is not required anymore.
%FUNCTION:END
%NEED:17
%FUNCTION:BEGIN
=== pmemdup ===[fn_pmemdup]

**Definition:**

%DEFINITION:BEGIN
void* pmemdup( void* ptr, size_t size )
%DEFINITION:END

**Usage:**

Duplicates a memory entry onto the heap.

//ptr// is the pointer to the memory to be duplicated.
//size// is the size of pointer's data storage.

Returns the new pointer to the memory copy. This should be cast back to the
type of //ptr// again.
%FUNCTION:END
%NEED:22
%FUNCTION:BEGIN
=== prealloc ===[fn_prealloc]

**Definition:**

%DEFINITION:BEGIN
void* prealloc( void* oldptr, size_t size )
%DEFINITION:END

**Usage:**

Dynamically (re)allocate memory on the heap.

The function wraps the system-function [realloc() #fn_realloc], but always accepts a
NULL-pointer and immediately stops the program if no more memory can be
allocated.

//oldptr// is the pointer to be reallocated. If this is (void*)NULL, [prealloc() #fn_prealloc] works like a normal call to [pmalloc() #fn_pmalloc].

//size// is the size of memory to be reallocated, in bytes.

The function returns the allocated heap memory pointer. The returned memory
address should be freed using [pfree() #fn_pfree] after it is not required any more.
%FUNCTION:END
%NEED:32
%FUNCTION:BEGIN
=== pregex_create ===[fn_pregex_create]

**Definition:**

%DEFINITION:BEGIN
pregex* pregex_create( char* pat, int flags )
%DEFINITION:END

**Usage:**

Constructor function to create a new pregex object.

//pat// is a string providing a regular expression pattern.
//flags// can be a combination of compile- and runtime-flags.

|| Flag | Usage |
| PREGEX_COMP_WCHAR | The regular expression //pat// is provided as wchar_t. |
| PREGEX_COMP_NOANCHORS | Ignore anchor tokens, handle them as normal characters |
| PREGEX_COMP_NOREF | Don't compile references. |
| PREGEX_COMP_NONGREEDY | Compile regex to be forced non-greedy. |
| PREGEX_COMP_NOERRORS | Don't report errors, and try to compile as much as possible |
| PREGEX_COMP_INSENSITIVE | Parse regular expression as case insensitive. |
| PREGEX_COMP_STATIC | The regular expression passed should be converted 1:1 as it where a string-constant. Any regex-specific symbols will be ignored and taken as they where escaped. |
| PREGEX_RUN_WCHAR | Run regular expression with wchar_t as input. |
| PREGEX_RUN_NOANCHORS | Ignore anchors while processing the regex. |
| PREGEX_RUN_NOREF | Don't create references. |
| PREGEX_RUN_NONGREEDY | Force run regular expression non-greedy. |
| PREGEX_RUN_DEBUG | Debug mode; output some debug to stderr. |


On success, the function returns the allocated pointer to a pregex-object.
This must be freed later using [pregex_free() #fn_pregex_free].
%FUNCTION:END
%NEED:21
%FUNCTION:BEGIN
=== pregex_find ===[fn_pregex_find]

**Definition:**

%DEFINITION:BEGIN
char* pregex_find( pregex* regex, char* start, char** end )
%DEFINITION:END

**Usage:**

Find a match for the regular expression //regex// from begin of pointer
//start//.

//start// has to be a zero-terminated string or wide-character string (according
to the configuration of the pregex-object).

If the expression can be matched, the function returns the pointer to the
position where the match begins. //end// receives the end pointer of the match,
when provided.

The function returns (char*)NULL in case that there is no match.
%FUNCTION:END
%NEED:18
%FUNCTION:BEGIN
=== pregex_findall ===[fn_pregex_findall]

**Definition:**

%DEFINITION:BEGIN
int pregex_findall( pregex* regex, char* start, parray** matches )
%DEFINITION:END

**Usage:**

Find all matches for the regular expression //regex// from begin of pointer
//start//, and optionally return matches as an array.

//start// has to be a zero-terminated string or wide-character string (according
to the configuration of the pregex-object).

The function fills the array //matches//, if provided, with items of size
prange. It returns the total number of matches.
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== pregex_free ===[fn_pregex_free]

**Definition:**

%DEFINITION:BEGIN
pregex* pregex_free( pregex* regex )
%DEFINITION:END

**Usage:**

Destructor function for a pregex-object.

//regex// is the pointer to a pregex-structure that will be released.

Returns always (pregex*)NULL.
%FUNCTION:END
%NEED:14
%FUNCTION:BEGIN
=== pregex_match ===[fn_pregex_match]

**Definition:**

%DEFINITION:BEGIN
pboolean pregex_match( pregex* regex, char* start, char** end )
%DEFINITION:END

**Usage:**

Tries to match the regular expression //regex// at pointer //start//.

If the expression can be matched, the function returns TRUE and //end// receives
the pointer to the last matched character.
%FUNCTION:END
%NEED:22
%FUNCTION:BEGIN
=== pregex_ptn_create ===[fn_pregex_ptn_create]

**Definition:**

%DEFINITION:BEGIN
pregex_ptn* pregex_ptn_create( char* pat, int flags )
%DEFINITION:END

**Usage:**

Constructs and parses a new pregex_ptn-structure from //pat//.

This function is a shortcut for a call to [pregex_ptn_parse() #fn_pregex_ptn_parse]. [pregex_ptn_create() #fn_pregex_ptn_create] directly takes //pat// as its input and returns the parsed
pregex_ptn structure which represents the internal representation of the
regular expression //pat//.

//flags// provides a combination of compile-time modifier flags
(PREGEX_COMP_...) if wanted, or 0 (PREGEX_FLAG_NONE) if no flags should be
used.

Returns an allocated pregex_ptn-node which must be freed using [pregex_ptn_free() #fn_pregex_ptn_free]
when it is not used anymore.
%FUNCTION:END
%NEED:19
%FUNCTION:BEGIN
=== pregex_ptn_create_alt ===[fn_pregex_ptn_create_alt]

**Definition:**

%DEFINITION:BEGIN
pregex_ptn* pregex_ptn_create_alt( pregex_ptn* left, ... )
%DEFINITION:END

**Usage:**

Constructs alternations of multiple patterns.

//left// is the first pattern of the alternation.
//...// are multiple pregex_ptn-pointers follow which become part of the
alternation. The last node must be specified as (pregex_ptn*)NULL.

Returns a pregex_ptn-node which can be child of another pattern construct or
part of a sequence. If there is only //left// assigned without other alternation
patterns, //left// will be returned back.
%FUNCTION:END
%NEED:17
%FUNCTION:BEGIN
=== pregex_ptn_create_char ===[fn_pregex_ptn_create_char]

**Definition:**

%DEFINITION:BEGIN
pregex_ptn* pregex_ptn_create_char( pccl* ccl )
%DEFINITION:END

**Usage:**

Constructs a character-class pattern.

//ccl// is the pointer to a character class. This pointer is not duplicated,
and will be directly assigned to the object.

Returns a pregex_ptn-node which can be child of another pattern construct or
part of a sequence.
%FUNCTION:END
%NEED:17
%FUNCTION:BEGIN
=== pregex_ptn_create_kle ===[fn_pregex_ptn_create_kle]

**Definition:**

%DEFINITION:BEGIN
pregex_ptn* pregex_ptn_create_kle( pregex_ptn* ptn )
%DEFINITION:END

**Usage:**

Constructs a kleene-closure repetition, allowing for multiple or none
repetitions of the specified pattern.

//ptn// is the pattern that will be configured for kleene-closure.

Returns a pregex_ptn-node which can be child of another pattern construct or
part of a sequence.
%FUNCTION:END
%NEED:16
%FUNCTION:BEGIN
=== pregex_ptn_create_opt ===[fn_pregex_ptn_create_opt]

**Definition:**

%DEFINITION:BEGIN
pregex_ptn* pregex_ptn_create_opt( pregex_ptn* ptn )
%DEFINITION:END

**Usage:**

Constructs an optional-closure, allowing for one or none specified pattern.

//ptn// is the pattern to be configured for optional closure.

Returns a pregex_ptn-node which can be child of another pattern construct or
part of a sequence.
%FUNCTION:END
%NEED:17
%FUNCTION:BEGIN
=== pregex_ptn_create_pos ===[fn_pregex_ptn_create_pos]

**Definition:**

%DEFINITION:BEGIN
pregex_ptn* pregex_ptn_create_pos( pregex_ptn* ptn )
%DEFINITION:END

**Usage:**

Constructs an positive-closure, allowing for one or multiple specified
pattern.

//ptn// is the pattern to be configured for positive closure.

Returns a pregex_ptn-node which can be child of another pattern construct or
part of a sequence.
%FUNCTION:END
%NEED:16
%FUNCTION:BEGIN
=== pregex_ptn_create_refsub ===[fn_pregex_ptn_create_refsub]

**Definition:**

%DEFINITION:BEGIN
pregex_ptn* pregex_ptn_create_refsub( pregex_ptn* ptn )
%DEFINITION:END

**Usage:**

Constructs a sub-pattern as backreference (like with parantheses).

//ptn// is the pattern that becomes the sub-ordered pattern.

Returns a pregex_ptn-node which can be child of another pattern construct
or part of a sequence.
%FUNCTION:END
%NEED:17
%FUNCTION:BEGIN
=== pregex_ptn_create_seq ===[fn_pregex_ptn_create_seq]

**Definition:**

%DEFINITION:BEGIN
pregex_ptn* pregex_ptn_create_seq( pregex_ptn* first, ... )
%DEFINITION:END

**Usage:**

Constructs a sequence of multiple patterns.

//first// is the beginning pattern of the sequence. //...// follows as parameter
list of multiple patterns that become part of the sequence. The last pointer
must be specified as (pregex_ptn*)NULL to mark the end of the list.

Always returns the pointer to //first//.
%FUNCTION:END
%NEED:17
%FUNCTION:BEGIN
=== pregex_ptn_create_string ===[fn_pregex_ptn_create_string]

**Definition:**

%DEFINITION:BEGIN
pregex_ptn* pregex_ptn_create_string( char* str, int flags )
%DEFINITION:END

**Usage:**

Constructs a pattern for a static string.

//str// is the input string to be converted.
//flags// are optional flags for wide-character support.

Returns a pregex_ptn-node which can be child of another pattern construct or
part of a sequence.
%FUNCTION:END
%NEED:16
%FUNCTION:BEGIN
=== pregex_ptn_create_sub ===[fn_pregex_ptn_create_sub]

**Definition:**

%DEFINITION:BEGIN
pregex_ptn* pregex_ptn_create_sub( pregex_ptn* ptn )
%DEFINITION:END

**Usage:**

Constructs a sub-pattern (like with parantheses).

//ptn// is the pattern that becomes the sub-ordered pattern.

Returns a pregex_ptn-node which can be child of another pattern construct
or part of a sequence.
%FUNCTION:END
%NEED:11
%FUNCTION:BEGIN
=== pregex_ptn_dup ===[fn_pregex_ptn_dup]

**Definition:**

%DEFINITION:BEGIN
pregex_ptn* pregex_ptn_dup( pregex_ptn* ptn )
%DEFINITION:END

**Usage:**

Duplicate //ptn// into a stand-alone 1:1 copy.
%FUNCTION:END
%NEED:16
%FUNCTION:BEGIN
=== pregex_ptn_free ===[fn_pregex_ptn_free]

**Definition:**

%DEFINITION:BEGIN
pregex_ptn* pregex_ptn_free( pregex_ptn* ptn )
%DEFINITION:END

**Usage:**

Releases memory of a pattern including all its subsequent and following
patterns.

//ptn// is the pattern object to be released.

Always returns (pregex_ptn*)NULL.
%FUNCTION:END
%NEED:21
%FUNCTION:BEGIN
=== pregex_ptn_parse ===[fn_pregex_ptn_parse]

**Definition:**

%DEFINITION:BEGIN
pboolean pregex_ptn_parse( pregex_ptn** ptn, char* str, int flags )
%DEFINITION:END

**Usage:**

Parse a regular expression pattern string into a pregex_ptn structure.

//ptn// is the return pointer receiving the root node of the generated pattern.

//str// is the pointer to the string which contains the pattern to be parsed. If
PREGEX_COMP_WCHAR is assigned in //flags//, this pointer must be set to a
wchar_t-array holding a wide-character string.

//flags// provides compile-time modifier flags (PREGEX_COMP_...).

Returns TRUE on success.
%FUNCTION:END
%NEED:14
%FUNCTION:BEGIN
=== pregex_ptn_print ===[fn_pregex_ptn_print]

**Definition:**

%DEFINITION:BEGIN
void pregex_ptn_print( pregex_ptn* ptn, int rec )
%DEFINITION:END

**Usage:**

A debug function to print a pattern's hierarchical structure to stderr.

//ptn// is the pattern object to be printed.
//rec// is the recursion depth, set this to 0 at initial call.
%FUNCTION:END
%NEED:18
%FUNCTION:BEGIN
=== pregex_ptn_to_dfa ===[fn_pregex_ptn_to_dfa]

**Definition:**

%DEFINITION:BEGIN
pboolean pregex_ptn_to_dfa( pregex_dfa* dfa, pregex_ptn* ptn )
%DEFINITION:END

**Usage:**

Converts a pattern-structure into a DFA state machine.

//dfa// is the DFA state machine structure that receives the compiled result of
the pattern. //dfa// must be initialized!
//ptn// is the pattern structure that will be converted and extended into
the DFA state machine.

Returns TRUE on success.
%FUNCTION:END
%NEED:60
%FUNCTION:BEGIN
=== pregex_ptn_to_dfatab ===[fn_pregex_ptn_to_dfatab]

**Definition:**

%DEFINITION:BEGIN
int pregex_ptn_to_dfatab( wchar_t*** dfatab, pregex_ptn* ptn )
%DEFINITION:END

**Usage:**

Converts a pattern-structure into a DFA state machine //dfatab//.

//ptn// is the pattern structure that will be converted into a DFA state
machine.

//dfatab// is a pointer to a variable that receives the allocated DFA state machine, where
each row forms a state that is made up of columns described in the table below.

|| Column / Index | Content |
| 0 | Total number of columns in the current row |
| 1 | Match ID if > 0, or 0 if the state is not an accepting state |
| 2 | Match flags (anchors, greedyness, (PREGEX_FLAG_*)) |
| 3 | Reference flags; The index of the flagged bits defines the number of reference |
| 4 | Default transition from the current state. If there is no transition, its value is set to the number of all states. |
| 5 | Transition: from-character |
| 6 | Transition: to-character |
| 7 | Transition: Goto-state |
| ... | more triples follow for each transition |


Example for a state machine that matches the regular expression ``@[a-z0-9]+``
that has match 1 and no references:

```
8 0 0 0 3 64 64 2
11 1 0 0 3 48 57 1 97 122 1
11 0 0 0 3 48 57 1 97 122 1
```

Interpretation:

```
00: col= 8 acc= 0 flg= 0 ref= 0 def= 3 tra=064(@);064(@):02
01: col=11 acc= 1 flg= 0 ref= 0 def= 3 tra=048(0);057(9):01 tra=097(a);122(z):01
02: col=11 acc= 0 flg= 0 ref= 0 def= 3 tra=048(0);057(9):01 tra=097(a);122(z):01
```

A similar dump like this interpretation above will be printed to stderr by the
function when //dfatab// is provided as (long***)NULL.

The pointer assigned to //dfatab// must be freed after usage using a for-loop:

```
for( i = 0; i < dfatab_cnt; i++ )
	pfree( dfatab[i] );

pfree( dfatab );
```

Returns the number of rows in //dfatab//, or a negative value in error case.
%FUNCTION:END
%NEED:22
%FUNCTION:BEGIN
=== pregex_ptn_to_nfa ===[fn_pregex_ptn_to_nfa]

**Definition:**

%DEFINITION:BEGIN
pboolean pregex_ptn_to_nfa( pregex_nfa* nfa, pregex_ptn* ptn )
%DEFINITION:END

**Usage:**

Converts a pattern-structure into a NFA state machine.

//nfa// is the NFA state machine structure that receives the compiled result of
the pattern. This machine will be extended to the pattern if it already contains
states. //nfa// must be previously initialized!

//ptn// is the pattern structure that will be converted and extended into
the NFA state machine.

//flags// are compile-time flags.

Returns TRUE on success.
%FUNCTION:END
%NEED:17
%FUNCTION:BEGIN
=== pregex_ptn_to_regex ===[fn_pregex_ptn_to_regex]

**Definition:**

%DEFINITION:BEGIN
char* pregex_ptn_to_regex( pregex_ptn* ptn )
%DEFINITION:END

**Usage:**

Turns a regular expression pattern back into a regular expression string.

//ptn// is the pattern object to be converted into a regex.

The returned pointer is dynamically allocated but part of //ptn//, so it should
not be freed by the caller. It is automatically freed when the pattern object
is released.
%FUNCTION:END
%NEED:27
%FUNCTION:BEGIN
=== pregex_qmatch ===[fn_pregex_qmatch]

**Definition:**

%DEFINITION:BEGIN
int pregex_qmatch( char* regex, char* str, int flags, parray** matches )
%DEFINITION:END

**Usage:**

Performs a regular expression match on a string, and returns an array of
matches via prange-structures, which hold pointers to the begin- and
end-addresses of all matches.

//regex// is the regular expression pattern to be processed.

//str// is the string on which the pattern will be executed.

//flags// are for regular expression compile- and runtime-mode switching.
Several of them can be used with the bitwise or-operator (|).

//matches// is the array of results to the matched substrings within //str//,
provided as parray-object existing of one prange-object for every match.
It is optional. //matches// must be released with [parray_free() #fn_parray_free] after its usage.

Returns the number of matches, which is the number of result entries in the
returned array //matches//. If the value is negative, an error occurred.
%FUNCTION:END
%NEED:27
%FUNCTION:BEGIN
=== pregex_qreplace ===[fn_pregex_qreplace]

**Definition:**

%DEFINITION:BEGIN
char* pregex_qreplace( char* regex, char* str, char* replace, int flags )
%DEFINITION:END

**Usage:**

Replaces all matches of a regular expression pattern within a string with
the replacement. Backreferences can be used with ``$x`` for each opening bracket
within the regular expression.

//regex// is the regular expression pattern to be processed.

//str// is the string on which the pattern will be executed.

//replace// is the string that will be inserted as replacement for each pattern
match. ``$x`` back-references can be used.

//flags// are for regular expression compile- and runtime-mode switching.
Several of them can be used with the bitwise or-operator (|).

Returns an allocated pointer to the generated string with the replacements.
This string must be released after its existence is no longer required by the
caller using [pfree() #fn_pfree].
%FUNCTION:END
%NEED:26
%FUNCTION:BEGIN
=== pregex_qsplit ===[fn_pregex_qsplit]

**Definition:**

%DEFINITION:BEGIN
int pregex_qsplit( char* regex, char* str, int flags, parray** matches )
%DEFINITION:END

**Usage:**

Performs a regular expression search on a string and uses the expression as
separator; All strings that where split are returned as //matches//-array.

//regex// is the regular expression pattern to be processed.

//str// is the string on which the pattern will be executed.

//flags// are for regular expression compile- and runtime-mode switching.
Several of them can be used with the bitwise or-operator (|).

//matches// is the array of results to the matched substrings within //str//,
provided as parray-object existing of one prange-object for every match.
It is optional. //matches// must be released with [parray_free() #fn_parray_free] after its usage.

Returns the number of split substrings, which is the number of result entries in
the returned array //matches//. If the value is negative, an error occured.
%FUNCTION:END
%NEED:23
%FUNCTION:BEGIN
=== pregex_replace ===[fn_pregex_replace]

**Definition:**

%DEFINITION:BEGIN
char* pregex_replace( pregex* regex, char* str, char* replacement )
%DEFINITION:END

**Usage:**

Replaces all matches of a regular expression object within a string //str//
with //replacement//. Backreferences in //replacement// can be used with //$x//
for each opening bracket within the regular expression.

//regex// is the pregex-object used for pattern matching.
//str// is the string on which //regex// will be executed.
//replacement// is the string that will be inserted as the replacement for each
match of a pattern described in //regex//. The notation //$x// can be used for
backreferences, where x is the offset of opening brackets in the pattern,
beginning at 1.

The function returns the string with the replaced elements, or (char*)NULL
in case of an error.
%FUNCTION:END
%NEED:24
%FUNCTION:BEGIN
=== pregex_split ===[fn_pregex_split]

**Definition:**

%DEFINITION:BEGIN
char* pregex_split( pregex* regex, char* start, char** end, char** next )
%DEFINITION:END

**Usage:**

Returns the range between string //start// and the next match of //regex//.

This function can be seen as a "negative match", so the substrings that are
not part of the match will be returned.

//start// has to be a zero-terminated string or wide-character string (according
to the configuration of the pregex-object).
//end// receives the last position of the string before the regex.
//next// receives the pointer of the next split element behind the matched
substring, so //next// should become the next //start// when [pregex_split() #fn_pregex_split] is
called in a loop.

The function returns (char*)NULL in case there is no more string to split, else
it returns //start//.
%FUNCTION:END
%NEED:19
%FUNCTION:BEGIN
=== pregex_splitall ===[fn_pregex_splitall]

**Definition:**

%DEFINITION:BEGIN
int pregex_splitall( pregex* regex, char* start, parray** matches )
%DEFINITION:END

**Usage:**

Split a string at all matches of the regular expression //regex// from
begin of pointer //start//, and optionally returns the substrings found as an
array.

//start// has to be a zero-terminated string or wide-character string (according
to the configuration of the pregex-object).

The function fills the array //matches//, if provided, with items of size
prange. It returns the total number of matches.
%FUNCTION:END
%NEED:23
%FUNCTION:BEGIN
=== pstr_to_wcs ===[fn_pstr_to_wcs]

**Definition:**

%DEFINITION:BEGIN
wchar_t* pstr_to_wcs( char* str, pboolean freestr )
%DEFINITION:END

**Usage:**

This functions converts an UTF-8-multi-byte string into a Unicode
wide-character string.

The function wraps [mbstowcs() #fn_mbstowcs], so [set_locale() #fn_set_locale] must be done before this
function works properly.

//str// is the zero-terminated multi-byte-character string to be converted
into a wide-character string.
//freestr// if value equals TRUE then //str// will be freed after successfull
conversion.

Returns the wide-character pendant of //str// as pointer to dynamically
allocated memory.
%FUNCTION:END
%NEED:17
%FUNCTION:BEGIN
=== pstrcasecmp ===[fn_pstrcasecmp]

**Definition:**

%DEFINITION:BEGIN
int pstrcasecmp( char* s1, char* s2 )
%DEFINITION:END

**Usage:**

Compare a string ignoring case-order.

//s1// is the string to compare with //s2//.
//s2// is the string to compare with //s1//.

Returns 0 if both strings are equal. Returns a value <0 if //s1// is lower than
//s2// or a value >0 if //s1// is greater than //s2//.
%FUNCTION:END
%NEED:19
%FUNCTION:BEGIN
=== pstrcatchar ===[fn_pstrcatchar]

**Definition:**

%DEFINITION:BEGIN
char* pstrcatchar( char* str, char chr )
%DEFINITION:END

**Usage:**

Dynamically appends a character to a string.

//str// is the pointer to a string to be appended. If this is (char*)NULL,
the string will be newly allocated. //chr// is the character to be appended
to str.

Returns a char*-pointer to the (possibly re-)allocated and appended string.
(char*)NULL is returned if no memory could be (re)allocated. This pointer must
be released with [pfree() #fn_pfree] when its existence is no longer required.
%FUNCTION:END
%NEED:24
%FUNCTION:BEGIN
=== pstrcatstr ===[fn_pstrcatstr]

**Definition:**

%DEFINITION:BEGIN
char* pstrcatstr( char* dest, char* src, pboolean freesrc )
%DEFINITION:END

**Usage:**

Dynamically appends a zero-terminated string to a dynamic string.

//str// is the pointer to a zero-terminated string to be appended.
If this is (char*)NULL, the string is newly allocated.

//append// is the string to be appended at the end of //str//.

//freesrc// frees the pointer provided as //append// automatically by
this function, if set to TRUE.

Returns a char*-pointer to (possibly re-)allocated and appended string.
(char*)NULL is returned if no memory could be (re)allocated, or both strings
were NULL. If //dest// is NULL and //freesrc// is FALSE, the function
automatically returns the pointer //src//. This pointer must be released with [pfree() #fn_pfree] when its existence is no longer required.
%FUNCTION:END
%NEED:17
%FUNCTION:BEGIN
=== pstrdup ===[fn_pstrdup]

**Definition:**

%DEFINITION:BEGIN
char* pstrdup( char* str )
%DEFINITION:END

**Usage:**

Duplicate a string in memory.

//str// is the string to be copied in memory. If //str// is provided as NULL,
the function will also return NULL.

Returns a char*-pointer to the newly allocated copy of //str//. This pointer
must be released with [pfree() #fn_pfree] when its existence is no longer required.
%FUNCTION:END
%NEED:14
%FUNCTION:BEGIN
=== pstrget ===[fn_pstrget]

**Definition:**

%DEFINITION:BEGIN
char* pstrget( char* str )
%DEFINITION:END

**Usage:**

Safely reads a string.

//str// is the string pointer to be safely read. If //str// is NULL, the
function returns a pointer to a static address holding an empty string.
%FUNCTION:END
%NEED:17
%FUNCTION:BEGIN
=== pstrlen ===[fn_pstrlen]

**Definition:**

%DEFINITION:BEGIN
size_t pstrlen( char* str )
%DEFINITION:END

**Usage:**

Return length of a string.

//str// is the parameter string to be evaluated. If (char*)NULL, the function
returns 0. [pstrlen() #fn_pstrlen] is much safer than [strlen() #fn_strlen] because it returns 0 when
a NULL-pointer is provided.

Returns the length of the string //str//.
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== pstrltrim ===[fn_pstrltrim]

**Definition:**

%DEFINITION:BEGIN
char* pstrltrim( char* s )
%DEFINITION:END

**Usage:**

Removes whitespace on the left of a string.

//s// is the string to be left-trimmed.

Returns //s//.
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== pstrlwr ===[fn_pstrlwr]

**Definition:**

%DEFINITION:BEGIN
char* pstrlwr( char* s )
%DEFINITION:END

**Usage:**

Convert a string to lower-case.

//s// is the acts both as input and output-string.

Returns //s//.
%FUNCTION:END
%NEED:18
%FUNCTION:BEGIN
=== pstrncasecmp ===[fn_pstrncasecmp]

**Definition:**

%DEFINITION:BEGIN
int pstrncasecmp( char* s1, char* s2, size_t n )
%DEFINITION:END

**Usage:**

Compare two strings ignoring case-order up to a maximum of //n// bytes.

//s1// is the string to compare with //s2//.
//s2// is the string to compare with //s1//.
//n// is the number of bytes to compare.

Returns 0 if both strings are equal. Returns a value <0 if //s1// is less than
//s2// or a value >0 if //s1// is greater than //s2//.
%FUNCTION:END
%NEED:23
%FUNCTION:BEGIN
=== pstrncatstr ===[fn_pstrncatstr]

**Definition:**

%DEFINITION:BEGIN
char* pstrncatstr( char* str, char* append, size_t n )
%DEFINITION:END

**Usage:**

Dynamically appends n-characters from one string to another string.

The function works similar to [pstrcatstr() #fn_pstrcatstr], but allows to copy only a maximum
of //n// characters from //append//.

//str// is the pointer to a string to be appended. If this is (char*)NULL,
the string is newly allocated. //append// is the begin of character sequence to
be appended. //n// is the number of characters to be appended to //str//.

Returns a char*-pointer to (possibly re-)allocated and appended string.
(char*)NULL is returned if no memory could be (re)allocated, or both strings
were NULL. This pointer must be released with [pfree() #fn_pfree] when its existence
is no longer required.
%FUNCTION:END
%NEED:24
%FUNCTION:BEGIN
=== pstrndup ===[fn_pstrndup]

**Definition:**

%DEFINITION:BEGIN
char* pstrndup( char* str, size_t len )
%DEFINITION:END

**Usage:**

Duplicate //n// characters from a string in memory.

The function mixes the functionalities of [strdup() #fn_strdup] and [strncpy() #fn_strncpy].
The resulting string will be zero-terminated.

//str// is the parameter string to be duplicated. If this is provided as
(char*)NULL, the function will also return (char*)NULL.
//n// is the number of characters to be copied and duplicated from //str//.
If //n// is greater than the length of //str//, copying will stop at the zero
terminator.

Returns a char*-pointer to the allocated memory holding the zero-terminated
string duplicate. This pointer must be released with [pfree() #fn_pfree] when its existence
is no longer required.
%FUNCTION:END
%NEED:23
%FUNCTION:BEGIN
=== pstrput ===[fn_pstrput]

**Definition:**

%DEFINITION:BEGIN
char* pstrput( char** str, char* val )
%DEFINITION:END

**Usage:**

Assign a string to a dynamically allocated pointer.
 [pstrput() #fn_pstrput] manages the assignment of a dynamically allocated string.

//str// is a pointer receiving the target pointer to be (re)allocated. If
//str// already references a string, this pointer will be freed and reassigned
to a copy of //val//.

//val// is the string to be assigned to //str// (as a independent copy).

Returns a pointer to the allocated heap memory on success, (char*)NULL else.
This is the same pointer as returned when calling ``*str``. The returned pointer
must be released with [pfree() #fn_pfree] or another call of [pstrput() #fn_pstrput]. Calling [pstrput() #fn_pstrput]
as ``pstrput( &p, (char*)NULL );`` is equivalent to ``p = pfree( &p )``.
%FUNCTION:END
%NEED:29
%FUNCTION:BEGIN
=== pstrrender ===[fn_pstrrender]

**Definition:**

%DEFINITION:BEGIN
char* pstrrender( char* tpl, ... )
%DEFINITION:END

**Usage:**

String rendering function.

Inserts multiple values dynamically into the according wildcards positions of
a template string. The function can be compared to the function of [pstrreplace() #fn_pstrreplace], but allows to replace multiple substrings by multiple replacement
strings.

//tpl// is the template string to be rendered with values.
//...// are the set of values to be inserted into the desired position;

These consist of three values each:

- //char* name// as a wildcard-name
- //char* value// as the replacement value for the wildcard
- //pboolean freeflag// defines if //value// shall be freed after processing
-

Returns an allocated string which is the result of rendering. This string must
be released by [pfree() #fn_pfree] or another function releasing heap memory when its
existence is no longer required.
%FUNCTION:END
%NEED:21
%FUNCTION:BEGIN
=== pstrreplace ===[fn_pstrreplace]

**Definition:**

%DEFINITION:BEGIN
char* pstrreplace( char* str, char* find, char* replace )
%DEFINITION:END

**Usage:**

Replace a substring sequence within a string.

//str// is the string to be replaced in. //find// is the substring to be
matched. //replace// is the string to be inserted for each match of the
substring //find//.

Returns a char* containing the allocated string which is the result of replacing
all occurences of //find// with //replace// in //str//.

This pointer must be released with [pfree() #fn_pfree] when its existence is no longer
required.
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== pstrrtrim ===[fn_pstrrtrim]

**Definition:**

%DEFINITION:BEGIN
char* pstrrtrim( char* s )
%DEFINITION:END

**Usage:**

Removes trailing whitespace on the right of a string.

//s// is the string to be right-trimmed.

Returns //s//.
%FUNCTION:END
%NEED:21
%FUNCTION:BEGIN
=== pstrsplit ===[fn_pstrsplit]

**Definition:**

%DEFINITION:BEGIN
int pstrsplit( char*** tokens, char* str, char* sep, int limit )
%DEFINITION:END

**Usage:**

Splits a string at a delimiting token and returns an allocated array of
token reference pointers.

//tokens// is an allocated array of tokenized array values.
Requires a pointer to char**.
//str// is the input string to be tokenized.
//sep// is the token separation substring.
//limit// is the token limit; If set to 0, there is no token limit available,
in which case as many as possible tokens are read.

Returns the number of separated tokens, or -1 on error.
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== pstrtrim ===[fn_pstrtrim]

**Definition:**

%DEFINITION:BEGIN
char* pstrtrim( char* s )
%DEFINITION:END

**Usage:**

Removes beginning and trailing whitespace from a string.

//s// is the string to be trimmed.

Returns //s//.
%FUNCTION:END
%NEED:40
%FUNCTION:BEGIN
=== pstrunescape ===[fn_pstrunescape]

**Definition:**

%DEFINITION:BEGIN
char* pstrunescape( char* str )
%DEFINITION:END

**Usage:**

Converts a string with included escape-sequences back into its natural form.

The following table shows escape sequences which are converted.

|| Sequence | is replaced by |
| \n | newline |
| \t | tabulator |
| \r | carriage-return |
| \b | backspace |
| \f | form feed |
| \a | bell / alert |
| \' | single-quote |
| \" | double-quote |


The replacement is done within the memory bounds of //str// itself, because the
unescaped version of the character requires less space than its previous escape
sequence.

The function always returns its input pointer.

**Example:**
```
char* s = (char*)NULL;

psetstr( &s, "\\tHello\\nWorld!" );
printf( ">%s<\n", pstrunescape( s ) );

s = pfree( s );
```
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== pstrupr ===[fn_pstrupr]

**Definition:**

%DEFINITION:BEGIN
char* pstrupr( char* s )
%DEFINITION:END

**Usage:**

Convert a string to upper-case.

//s// acts both as input- and output string.

Returns //s//.
%FUNCTION:END
%NEED:14
%FUNCTION:BEGIN
=== putf8_char ===[fn_putf8_char]

**Definition:**

%DEFINITION:BEGIN
wchar_t putf8_char( char* str )
%DEFINITION:END

**Usage:**

Return single character (as wide-character value) from UTF-8 multi-byte
character string.

//str// is the pointer to character sequence begin.
%FUNCTION:END
%NEED:14
%FUNCTION:BEGIN
=== putf8_isutf ===[fn_putf8_isutf]

**Definition:**

%DEFINITION:BEGIN
pboolean putf8_isutf( unsigned char c )
%DEFINITION:END

**Usage:**

Check for UTF-8 character sequence signature.

The function returns TRUE, if the character //c// is the beginning of a UTF-8
character signature, else FALSE.
%FUNCTION:END
%NEED:18
%FUNCTION:BEGIN
=== putf8_move ===[fn_putf8_move]

**Definition:**

%DEFINITION:BEGIN
char* putf8_move( char* str, int count )
%DEFINITION:END

**Usage:**

Moves //count// characters ahead in an UTF-8 multi-byte character sequence.

//str// is the pointer to UTF-8 string to begin moving.
//count// is the number of characters to move left.

The function returns the address of the next UTF-8 character sequence after
//count// characters. If the string's end is reached, it will return a
pointer to the zero-terminator.
%FUNCTION:END
%NEED:17
%FUNCTION:BEGIN
=== putf8_parse_char ===[fn_putf8_parse_char]

**Definition:**

%DEFINITION:BEGIN
wchar_t putf8_parse_char( char** ch )
%DEFINITION:END

**Usage:**

Read one character from an UTF-8 input sequence.
This character can be escaped, an UTF-8 character or an ordinary ASCII-char.

//chr// is the input- and output-pointer (the pointer is replaced by the pointer
to the next character or escape-sequence within the string).

The function returns the character code of the parsed character.
%FUNCTION:END
%NEED:15
%FUNCTION:BEGIN
=== putf8_seqlen ===[fn_putf8_seqlen]

**Definition:**

%DEFINITION:BEGIN
int putf8_seqlen(char *s)
%DEFINITION:END

**Usage:**

Returns length of next UTF-8 sequence in a multi-byte character string.

//s// is the pointer to begin of UTF-8 sequence.

Returns the number of bytes used for the next character.
%FUNCTION:END
%NEED:17
%FUNCTION:BEGIN
=== pvasprintf ===[fn_pvasprintf]

**Definition:**

%DEFINITION:BEGIN
int pvasprintf( char** str, char* fmt, va_list ap )
%DEFINITION:END

**Usage:**

Implementation and replacement for vasprintf.

//str// is the pointer receiving the result, allocated string pointer.
//fmt// is the format string.
//...// are the parameters according to the placeholders set in //fmt//.

Returns the number of characters written, or -1 in case of an error.
%FUNCTION:END
%NEED:19
%FUNCTION:BEGIN
=== pvawcsprintf ===[fn_pvawcsprintf]

**Definition:**

%DEFINITION:BEGIN
int pvawcsprintf( wchar_t** str, wchar_t* fmt, va_list ap )
%DEFINITION:END

**Usage:**

Wide-character implementation of [pasprintf() #fn_pasprintf].

//str// is the a pointer receiving the resultung, allocated string pointer.
//fmt// is the the format string.
//...// is the parameters according to the placeholders set in //fmt//.

Returns the number of characters written.

//This function is only available when compiled with -DUNICODE.//
%FUNCTION:END
%NEED:22
%FUNCTION:BEGIN
=== pwcs_to_str ===[fn_pwcs_to_str]

**Definition:**

%DEFINITION:BEGIN
char* pwcs_to_str( wchar_t* str, pboolean freestr )
%DEFINITION:END

**Usage:**

This functions converts a wide-character string into an UTF-8 string.

The string conversion is performed into dynamically allocated memory.
The function wraps the system function [wcstombs() #fn_wcstombs], so [set_locale() #fn_set_locale] must be
called before this function works properly.

//str// is the zero-terminated string to be converted to UTF-8.
//freestr// defines if the input-string shall be freed after successful
conversion, if set to TRUE.

Returns the UTF-8 character pendant of //str// as pointer to dynamically
allocated memory.
%FUNCTION:END
%NEED:20
%FUNCTION:BEGIN
=== pwcscatchar ===[fn_pwcscatchar]

**Definition:**

%DEFINITION:BEGIN
wchar_t* pwcscatchar( wchar_t* str, wchar_t chr )
%DEFINITION:END

**Usage:**

Appends a character to a dynamic wide-character string.

//str// is the pointer to a wchar_t-string to be appended. If this is
(wchar_t*)NULL, the string is newly allocated. //chr// is the the character
to be appended to str.

Returns a wchar_t* Pointer to (possibly re-)allo- cated and appended string.
(wchar_t*)NULL is returned if no memory could be (re)allocated.

//This function is only available when compiled with -DUNICODE.//
%FUNCTION:END
%NEED:23
%FUNCTION:BEGIN
=== pwcscatstr ===[fn_pwcscatstr]

**Definition:**

%DEFINITION:BEGIN
wchar_t* pwcscatstr( wchar_t* dest, wchar_t* src, pboolean freesrc )
%DEFINITION:END

**Usage:**

Appends a (possibly dynamic) wide-character string to a dynamic
wide-character string.

//str// is the pointer to a wchar_t-string to be appended. If this is
(wchar_t*)NULL, the string is newly allocated.
//append// is the string to be appended.
//freesrc// if true, //append// is free'd automatically by this function.

Returns a wchar_t* Pointer to (possibly re-)allo- cated and appended string.
(wchar_t*)NULL is returned if no memory could be (re)allocated, or both strings
were NULL.

//This function is only available when compiled with -DUNICODE.//
%FUNCTION:END
%NEED:19
%FUNCTION:BEGIN
=== pwcsdup ===[fn_pwcsdup]

**Definition:**

%DEFINITION:BEGIN
wchar_t* pwcsdup( wchar_t* str )
%DEFINITION:END

**Usage:**

Duplicate a wide-character string in memory.

//str// is the string to be copied in memory. If //str// is provided as NULL,
the function will also return NULL.

Returns a wchar_t*-pointer to the newly allocated copy of //str//. This pointer
must be released with [pfree() #fn_pfree] when its existence is no longer required.

//This function is only available when compiled with -DUNICODE.//
%FUNCTION:END
%NEED:16
%FUNCTION:BEGIN
=== pwcsget ===[fn_pwcsget]

**Definition:**

%DEFINITION:BEGIN
wchar_t* pwcsget( wchar_t* str )
%DEFINITION:END

**Usage:**

Safely reads a wide-character string.

//str// is the string pointer to be safely read. If //str// is NULL, the
function returns a pointer to a static address holding an empty string.

//This function is only available when compiled with -DUNICODE.//
%FUNCTION:END
%NEED:16
%FUNCTION:BEGIN
=== pwcslen ===[fn_pwcslen]

**Definition:**

%DEFINITION:BEGIN
size_t pwcslen( wchar_t* str )
%DEFINITION:END

**Usage:**

Safe strlen replacement for wide-character.

//str// is the parameter string to be evaluated. If (wchar_t*)NULL,
the function returns 0.

//This function is only available when compiled with -DUNICODE.//
%FUNCTION:END
%NEED:22
%FUNCTION:BEGIN
=== pwcsncatstr ===[fn_pwcsncatstr]

**Definition:**

%DEFINITION:BEGIN
wchar_t* pwcsncatstr( wchar_t* str, wchar_t* append, size_t n )
%DEFINITION:END

**Usage:**

Appends //n// characters from one wide-character string to a dynamic string.

//str// is the pointer to a wchar_t-string to be appended. If this is
(wchar_t*)NULL, the string is newly allocated.
//append// is the begin of character sequence to be appended.
//n// is the number of characters to be appended to str.

Returns a wchar_t* Pointer to (possibly re-)allo- cated and appended string.
(wchar_t*)NULL is returned if no memory could be (re)allocated, or both strings
were NULL.

//This function is only available when compiled with -DUNICODE.//
%FUNCTION:END
%NEED:28
%FUNCTION:BEGIN
=== pwcsndup ===[fn_pwcsndup]

**Definition:**

%DEFINITION:BEGIN
wchar_t* pwcsndup( wchar_t* str, size_t len )
%DEFINITION:END

**Usage:**

Duplicate //n// characters from a wide-character string in memory.

The function mixes the functionalities of [wcsdup() #fn_wcsdup] and [wcsncpy() #fn_wcsncpy].
The resulting wide-character string will be zero-terminated.

//str// is the parameter wide-character string to be duplicated.
If this is provided as (wchar_t*)NULL, the function will also return
(wchar_t*)NULL.

//n// is the the number of characters to be copied and duplicated from //str//.
If //n// is greater than the length of //str//, copying will stop at the zero
terminator.

Returns a wchar_t*-pointer to the allocated memory holding the zero-terminated
wide-character string duplicate. This pointer must be released with [pfree() #fn_pfree]
when its existence is no longer required.

//This function is only available when compiled with -DUNICODE.//
%FUNCTION:END
%NEED:27
%FUNCTION:BEGIN
=== pwcsput ===[fn_pwcsput]

**Definition:**

%DEFINITION:BEGIN
wchar_t* pwcsput( wchar_t** str, wchar_t* val )
%DEFINITION:END

**Usage:**

Assign a wide-character string to a dynamically allocated pointer.
 [pwcsput() #fn_pwcsput] manages the assignment of an dynamically allocated  wide-chararacter
string.

//str// is a pointer receiving the target pointer to be (re)allocated. If
//str// already references a wide-character string, this pointer will be freed
and reassigned to a copy of //val//.

//val// is the the wide-character string to be assigned to //str//
(as an independent copy).

Returns a pointer to the allocated heap memory on success, (char_t*)NULL else.
This is the same pointer as returned when calling ``*str``. The returned pointer
must be released with [pfree() #fn_pfree] or another call of [pwcsput() #fn_pwcsput]. Calling [pwcsput() #fn_pwcsput]
as ``pwcsput( &p, (char*)NULL );`` is equivalent to ``p = pfree( &p )``.

//This function is only available when compiled with -DUNICODE.//
%FUNCTION:END
%NEED:22
%FUNCTION:BEGIN
=== pwhich ===[fn_pwhich]

**Definition:**

%DEFINITION:BEGIN
char* pwhich( char* filename, char* directories )
%DEFINITION:END

**Usage:**

Figures out a filepath by searching in a PATH definition.

//filename// is the filename to be searched for.

//directories// is a string specifying the directories to search in.
If this is (char*)NULL, the environment variable PATH will be used and
evaluated by using  [getenv() #fn_getenv] #fn_getenv]. The path can be split with multiple
paths by a character that depends on the current platform
(Unix: ":", Windows: ";").

Returns a static pointer to the absolute path that contains the file specified
as filename, else it will return (char*)NULL.
%FUNCTION:END
